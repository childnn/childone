递归:
  1. 严格定义递归函数作用, 包括参数, 返回值, Side-effect
  2. 先一般, 后特殊
  3. 每次调用必须缩小问题规模
  4. 每次问题规模缩小程度必须为 1


二叉树: 左子树的节点值比父节点小, 右子树节点值比父节点大.
普通二叉树可能出现一种极端情况: 退化为一条链表.
平衡二叉树:
    1. 具有二叉树的全部特征
    2. 每个节点的左子树和右子树高度差之多等于 1.
红黑树:
    虽然平衡二叉树解决了二叉查找树退化为近似链表的缺点, 不过平衡树要求每个节点的
    左子树和右子树的高度差至多等于 1, 这个要求实在是太严了, 导致每次进行插入/删除节点的时候,
    几乎都会破坏平衡术的第二个规则, 进而都需要通过 左旋 和右旋来进行调整, 使之再次成为一颗符合要求的平衡树.
    显然, 如果在那种插入,删除很频繁的场景中,平衡树需要频繁调整,这会使平衡树的性能大打折扣, 为了解决这个问题,
    于是有了 红黑树
    1. 具有二叉树的特点.
    2. 根节点是黑色
    3. 每个叶子节点都是黑色的空节点,即叶子节点不存数据
    4. 任何相邻的节点都不能同时为红色, 即红色节点是被黑色节点隔开的
    5.每个节点, 从该节点到达其可达叶子节点的所有路径, 都包含相同数目的黑色节点.
与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。


算法：algorithm
    被明确定义的有限个规则的集合,用于根据有限的步骤解决问题.
    例如在既定的精度下,把求解 sin x 的计算步骤无一遗漏的记录下来的文字.
  简而言之: 算法就是 把解决问题的步骤无一遗漏地用文字或图表示出来.
    把这些 "用文字或图表示" 替换为 "用编程语言表达", 算法就变成了程序.
    并且, 必须满足条件 "算法的步骤必须是明确的并且步骤数必须是有限的".

排序
---
排序术语
  稳定: 如果 a 原本在 b 前面, 且 a = b, 排序之后 a 仍然在 b 前面
  不稳定: 如果 a 原本在 b 前面, 且 a = b, 排序后 a 可能会出现在 b 后面
  内排序: 所有排序操作都在内存中完成
  外排序: 由于数据太大, 因此把数据放在磁盘中, 而排序通过磁盘和内存的数据传输才能进行
  时间复杂度: 一个算法执行所耗费的时间
  空间复杂度: 运行完一个程序所需内存的大小
  ---
  比较排序: 常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，
       元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
       在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为 O(n²)。
       在归并排序、快速排序之类的排序中，问题规模通过分治法消减为 logN 次，所以时间复杂度平均 O(nlogn)。
       比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
  非比较排序: 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。
       针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。非比较排序只要确定
       每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，
       但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

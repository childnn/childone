<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8"/>
    <!--
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <meta name="referrer" content="never"/>
        <meta property="og:description"
              content="一：Spring缓存抽象 Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口"/>
        <meta http-equiv="Cache-Control" content="no-transform"/>
        <meta http-equiv="Cache-Control" content="no-siteapp"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
        <title>史上最全的Spring Boot Cache使用与整合 - 卡布哒 - 博客园</title>

        <link rel="stylesheet" href="/css/blog-common.min.css?v=PyyhYDRKBG1sYtpoHme_xHO5AMd5iN57I45iBKF8FVY"/>
        <link id="MainCss" rel="stylesheet"
              href="/skins/custom/bundle-custom.min.css?v=1ssrnY3Il79Ok472qeVrpxlSprSXcHhYPgZC5S3wtVM"/>
        <link type="text/css" rel="stylesheet"
              href="https://www.cnblogs.com/yueshutong/custom.css?v=jOvT20sElQrA7zmBQk5noqBiFeM="/>
        <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet"
              href="/skins/custom/bundle-custom-mobile.min.css?v=m3EDfkzWxyr59QpsMnTcyqVxwFbVIdAtRy2EooJcJ94"/>

        <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/yueshutong/rss"/>
        <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/yueshutong/rsd.xml"/>
        <link type="application/wlwmanifest+xml" rel="wlwmanifest"
              href="https://www.cnblogs.com/yueshutong/wlwmanifest.xml"/>
        <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
        <script src="/js/blog-common.min.js?v=9AUvV7CGRXeBxRXvxWjIJxJZemektvGlJfH8yBiYzRQ"></script>
        <script>
            var currentBlogId = 344744;
            var currentBlogApp = 'yueshutong';
            var cb_enable_mathjax = false;
            var isLogined = true;
        </script>
    -->


</head>
<body>
<a name="top"></a>


<!--done-->
<div id="home">
    <!--    <div id="header">-->
    <!--        <div id="blogTitle">-->
    <!--            <a id="lnkBlogLogo" href="https://www.cnblogs.com/yueshutong/"><img id="blogLogo"-->
    <!--                                                                                src="/skins/custom/images/logo.gif"-->
    <!--                                                                                alt="返回主页"/></a>-->

    <!--            &lt;!&ndash;done&ndash;&gt;-->
    <!--            <h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle"-->
    <!--                   href="https://www.cnblogs.com/yueshutong/">编程技术进阶</a>-->
    <!--            </h1>-->
    <!--            <h2>-->
    <!--                所谓的人生开挂，不过是厚积薄发！-->
    <!--            </h2>-->


    <!--        </div>&lt;!&ndash;end: blogTitle 博客的标题和副标题 &ndash;&gt;-->
    <!--        <div id="navigator">-->

    <!--            <ul id="navList">-->
    <!--                <li>-->
    <!--                </li>-->
    <!--                <li>-->
    <!--                    <a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/yueshutong/">-->
    <!--                        首页</a>-->
    <!--                </li>-->
    <!--                <li>-->

    <!--                    <a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">-->
    <!--                        新随笔</a>-->
    <!--                </li>-->
    <!--                <li>-->
    <!--                    <a id="blog_nav_contact" class="menu"-->
    <!--                       href="https://msg.cnblogs.com/send/%E5%8D%A1%E5%B8%83%E5%93%92">-->
    <!--                        联系</a></li>-->
    <!--                <li>-->
    <!--                    <a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/yueshutong/rss/">-->
    <!--                        订阅</a>-->
    <!--                    &lt;!&ndash;<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>&ndash;&gt;</li>-->
    <!--                <li>-->
    <!--                    <a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">-->
    <!--                        管理</a>-->
    <!--                </li>-->
    <!--            </ul>-->


    <!--            <div class="blogStats">-->

    <!--			<span id="stats_post_count">随笔 - -->
    <!--223&nbsp; </span>-->
    <!--                <span id="stats_article_count">文章 - -->
    <!--0&nbsp; </span>-->
    <!--                <span id="stats-comment_count">评论 - -->
    <!--228</span>-->


    <!--            </div>&lt;!&ndash;end: blogStats &ndash;&gt;-->
    <!--        </div>&lt;!&ndash;end: navigator 博客导航栏 &ndash;&gt;-->
    <!--    </div>&lt;!&ndash;end: header 头部 &ndash;&gt;-->

    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
                    <!--done-->
                    <div id="topics">
                        <div class="post">
                            <h1 class="postTitle">

                                <!--<a id="cb_post_title_url" class="postTitle2"
                                   href="https://www.cnblogs.com/yueshutong/p/9381540.html">史上最全的Spring Boot
                                    Cache使用与整合</a>-->

                            </h1>
                            <div class="clear"></div>
                            <div class="postBody">

                                <div class="blogpost-body " id="cnblogs_post_body">
                                    <h2 id="一spring缓存抽象">一：Spring缓存抽象</h2>
                                    <p>
                                        Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发；</p>
                                    <ul>
                                        <li>
                                            <p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p>
                                        </li>
                                        <li>
                                            <p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache
                                                ,ConcurrentMapCache等；</p>
                                        </li>
                                        <li>
                                            <p>
                                                每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p>
                                        </li>
                                        <li>
                                            <p>使用Spring缓存抽象时我们需要关注以下两点；</p>
                                            <p>1、确定方法需要被缓存以及他们的缓存策略</p>
                                            <p>2、从缓存中读取之前缓存存储的数据</p>
                                        </li>
                                    </ul>
                                    <h2 id="二几个重要概念缓存注解">二：几个重要概念&amp;缓存注解</h2>
                                    <table>
                                        <thead>
                                        <tr>
                                            <th>名称</th>
                                            <th align="left">解释</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>Cache</td>
                                            <td align="left">
                                                缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等
                                            </td>
                                        </tr>
                                        <tr>
                                            <td>CacheManager</td>
                                            <td align="left">缓存管理器，管理各种缓存（cache）组件</td>
                                        </tr>
                                        <tr>
                                            <td>@Cacheable</td>
                                            <td align="left">主要针对方法配置，能够根据方法的请求参数对其进行缓存</td>
                                        </tr>
                                        <tr>
                                            <td>@CacheEvict</td>
                                            <td align="left">清空缓存</td>
                                        </tr>
                                        <tr>
                                            <td>@CachePut</td>
                                            <td align="left">保证方法被调用，又希望结果被缓存。<br/>与@Cacheable区别在于是否每次都调用方法，常用于更新</td>


                                        </tr>
                                        <tr>
                                            <td>@EnableCaching</td>
                                            <td align="left">开启基于注解的缓存</td>


                                        </tr>
                                        <tr>
                                            <td>keyGenerator</td>
                                            <td align="left">缓存数据时key生成策略</td>


                                        </tr>
                                        <tr>
                                            <td>serialize</td>
                                            <td align="left">缓存数据时value序列化策略</td>


                                        </tr>
                                        <tr>
                                            <td>@CacheConfig</td>
                                            <td align="left">统一配置本类的缓存注解的属性</td>


                                        </tr>


                                        </tbody>


                                    </table>
                                    <p><strong>@Cacheable/@CachePut/@CacheEvict 主要的参数</strong></p>
                                    <table>
                                        <thead>
                                        <tr>
                                            <th>名称</th>
                                            <th>解释</th>
                                        </tr>


                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>value</td>
                                            <td>缓存的名称，在 spring 配置文件中定义，必须指定至少一个<br/>例如：<br/>@Cacheable(value=&rdquo;mycache&rdquo;)
                                                或者<br/>@Cacheable(value={&rdquo;cache1&rdquo;,&rdquo;cache2&rdquo;}
                                            </td>


                                        </tr>
                                        <tr>
                                            <td>key</td>
                                            <td>缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，<br/>如果不指定，则缺省按照方法的所有参数进行组合<br/>例如：<br/>@Cacheable(value=&rdquo;testcache&rdquo;,key=&rdquo;#id&rdquo;)
                                            </td>


                                        </tr>
                                        <tr>
                                            <td>condition</td>
                                            <td>缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，<br/>只有为 true 才进行缓存/清除缓存<br/>例如：@Cacheable(value=&rdquo;testcache&rdquo;,condition=&rdquo;#userName.length()&gt;2&rdquo;)
                                            </td>


                                        </tr>
                                        <tr>
                                            <td>unless</td>
                                            <td>否定缓存。当条件结果为TRUE时，就不会缓存。<br/>@Cacheable(value=&rdquo;testcache&rdquo;,unless=&rdquo;#userName.length()&gt;2&rdquo;)
                                            </td>


                                        </tr>
                                        <tr>
                                            <td>allEntries<br/>(@CacheEvict )</td>
                                            <td>是否清空所有缓存内容，缺省为 false，如果指定为 true，<br/>则方法调用后将立即清空所有缓存<br/>例如：<br/>@CachEvict(value=&rdquo;testcache&rdquo;,allEntries=true)
                                            </td>


                                        </tr>
                                        <tr>
                                            <td>beforeInvocation<br/>(@CacheEvict)</td>
                                            <td>是否在方法执行前就清空，缺省为 false，如果指定为 true，<br/>则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法<br/>执行抛出异常，则不会清空缓存<br/>例如：<br/>@CachEvict(value=&rdquo;testcache&rdquo;，beforeInvocation=true)
                                            </td>


                                        </tr>


                                        </tbody>


                                    </table>
                                    <h2 id="三spel上下文数据">三：SpEL上下文数据</h2>
                                    <p>Spring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档：</p>
                                    <table>
                                        <thead>
                                        <tr>
                                            <th>名称</th>
                                            <th>位置</th>
                                            <th>描述</th>
                                            <th>示例</th>
                                        </tr>


                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>methodName</td>
                                            <td>root对象</td>
                                            <td>当前被调用的方法名</td>
                                            <td><code>#root.methodname</code></td>


                                        </tr>
                                        <tr>
                                            <td>method</td>
                                            <td>root对象</td>
                                            <td>当前被调用的方法</td>
                                            <td><code>#root.method.name</code></td>


                                        </tr>
                                        <tr>
                                            <td>target</td>
                                            <td>root对象</td>
                                            <td>当前被调用的目标对象实例</td>
                                            <td><code>#root.target</code></td>


                                        </tr>
                                        <tr>
                                            <td>targetClass</td>
                                            <td>root对象</td>
                                            <td>当前被调用的目标对象的类</td>
                                            <td><code>#root.targetClass</code></td>


                                        </tr>
                                        <tr>
                                            <td>args</td>
                                            <td>root对象</td>
                                            <td>当前被调用的方法的参数列表</td>
                                            <td><code>#root.args[0]</code></td>


                                        </tr>
                                        <tr>
                                            <td>caches</td>
                                            <td>root对象</td>
                                            <td>当前方法调用使用的缓存列表</td>
                                            <td><code>#root.caches[0].name</code></td>


                                        </tr>
                                        <tr>
                                            <td>Argument Name</td>
                                            <td>执行上下文</td>
                                            <td>当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数</td>
                                            <td><code>#artsian.id</code></td>


                                        </tr>
                                        <tr>
                                            <td>result</td>
                                            <td>执行上下文</td>
                                            <td>方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false）</td>
                                            <td><code>#result</code></td>


                                        </tr>


                                        </tbody>


                                    </table>
                                    <p><strong>注意：</strong></p>
                                    <p>1.当我们要使用root对象的属性作为key时我们也可以将&ldquo;#root&rdquo;省略，因为Spring默认使用的就是root对象的属性。
                                        如 </p>
                                    <p><code>@Cacheable(key = "targetClass + methodName +#p0")</code></p>
                                    <p>2.使用方法参数时我们可以直接使用&ldquo;#参数名&rdquo;或者&ldquo;#p参数index&rdquo;。 如：</p>
                                    <p><code>@Cacheable(value="users", key="#id")</code></p>
                                    <p><code>@Cacheable(value="users", key="#p0")</code></p>
                                    <p><strong>SpEL提供了多种运算符</strong></p>
                                    <table>
                                        <thead>
                                        <tr>
                                            <th><strong>类型</strong></th>
                                            <th><strong>运算符</strong></th>
                                        </tr>


                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>关系</td>
                                            <td>&lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne</td>


                                        </tr>
                                        <tr>
                                            <td>算术</td>
                                            <td>+，- ，* ，/，%，^</td>


                                        </tr>
                                        <tr>
                                            <td>逻辑</td>
                                            <td>&amp;&amp;，||，!，and，or，not，between，instanceof</td>


                                        </tr>
                                        <tr>
                                            <td>条件</td>
                                            <td>?: (ternary)，?: (elvis)</td>


                                        </tr>
                                        <tr>
                                            <td>正则表达式</td>
                                            <td>matches</td>


                                        </tr>
                                        <tr>
                                            <td>其他类型</td>
                                            <td>?.，?[&hellip;]，![&hellip;]，^[&hellip;]，$[&hellip;]</td>


                                        </tr>


                                        </tbody>


                                    </table>
                                    <p>以上的知识点适合你遗忘的时候来查阅，下面正式进入学习！</p>
                                    <h2 id="四开始使用">四：开始使用</h2>
                                    <p>环境：Spring boot 2.0.3</p>
                                    <p>IDE：IDEA</p>
                                    <h3 id="1开始使用前需要导入依赖">1.开始使用前需要导入依赖</h3>
                                    <pre class="prettyprint"><code class=" hljs xml">        <span class="hljs-tag">&lt;<span
                                            class="hljs-title">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework.boot<span
                                                class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span
                    class="hljs-title">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span
                                                class="hljs-title">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre>
                                    <h3 id="2然后在启动类注解enablecaching开启缓存">2.然后在启动类注解@EnableCaching开启缓存</h3>
                                    <pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@SpringBootApplication</span>
<span class="hljs-annotation">@EnableCaching</span>  <span class="hljs-comment">//开启缓存</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                                                class="hljs-title">DemoApplication</span>{</span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span
                                                class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}</code></pre>
                                    <h3>3.缓存@Cacheable<code></code></h3>
                                    <p><code>@Cacheable</code>注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。</p>
                                    <pre class="prettyprint"><code class=" hljs cs">    @Cacheable(<span
                                            class="hljs-keyword">value</span> = <span class="hljs-string">"emp"</span> ,key = <span
                                            class="hljs-string">"targetClass + methodName +#p0"</span>)
    <span class="hljs-keyword">public</span> List&lt;NewJob&gt; <span class="hljs-title">queryAll</span>(User uid) {
        <span class="hljs-keyword">return</span> newJobDao.findAllByUid(uid);
    }</code></pre>
                                    <p>此处的<code>value</code>是必需的，它指定了你的缓存存放在哪块命名空间。</p>
                                    <p>此处的<code>key</code>是使用的spEL表达式，参考上章。这里有一个小坑，如果你把<code>methodName</code>换成<code>method</code>运行会报错，观察它们的返回类型，原因在于<code>methodName</code>是<code>String</code>而<code>methoh</code>是<code>Method</code>。
                                    </p>
                                    <p>此处的<code>User</code>实体类一定要实现序列化<code>public class User implements
                                        Serializable</code>，否则会报<code>java.io.NotSerializableException</code>异常。</p>
                                    <p>到这里，你已经可以运行程序检验缓存功能是否实现。</p>
                                    <p><strong>深入源码，查看它的其它属性</strong></p>
                                    <p>我们打开<code>@Cacheable</code>注解的源码，可以看到该注解提供的其他属性，如：</p>
                                    <pre class="prettyprint"><code class=" hljs scss">String<span
                                            class="hljs-attr_selector">[]</span> <span class="hljs-function">cacheNames()</span> <span
                                            class="hljs-value">default</span> {}; <span class="hljs-comment">//和value注解差不多，二选一</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> keyGenerator() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//key的生成器。key/keyGenerator二选一使用</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheManager() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span
                                            class="hljs-comment">//指定缓存管理器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheResolver() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//或者指定获取解析器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> condition() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span
                                            class="hljs-comment">//条件符合则缓存</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> unless() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//条件符合则不缓存</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs java"><span
                                            class="hljs-keyword">boolean</span> sync() <span class="hljs-keyword">default</span> <span
                                            class="hljs-keyword">false</span>; <span
                                            class="hljs-comment">//是否使用异步模式</span></code></pre>
                                    <h3 id="4配置cacheconfig">4.配置@CacheConfig</h3>
                                    <p>当我们需要缓存的地方越来越多，你可以使用<code>@CacheConfig(cacheNames =
                                        {"myCache"})</code>注解来统一指定<code>value</code>的值，这时可省略<code>value</code>，如果你在你的方法依旧写上了<code>value</code>，那么依然以方法的<code>value</code>值为准。
                                    </p>
                                    <p>使用方法如下：</p>
                                    <pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@CacheConfig</span>(cacheNames = {<span
                                            class="hljs-string">"myCache"</span>})
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                                                class="hljs-title">BotRelationServiceImpl</span> <span
                                                class="hljs-keyword">implements</span> <span class="hljs-title">BotRelationService</span> {</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-annotation">@Cacheable</span>(key = <span
                                                class="hljs-string">"targetClass + methodName +#p0"</span>)<span
                                                class="hljs-comment">//此处没写value</span>
    <span class="hljs-keyword">public</span> List&lt;BotRelation&gt; <span class="hljs-title">findAllLimit</span>(<span
                                                class="hljs-keyword">int</span> num) {
        <span class="hljs-keyword">return</span> botRelationRepository.findAllLimit(num);
    }
    .....
}</code></pre>
                                    <p><strong>查看它的其它属性</strong></p>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> keyGenerator() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//key的生成器。key/keyGenerator二选一使用</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheManager() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//指定缓存管理器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheResolver() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//或者指定获取解析器</span></code></pre>
                                    <h3 id="5更新cacheput">5.更新@CachePut</h3>
                                    <p><code>@CachePut</code>注解的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和
                                        <code>@Cacheable</code> 不同的是，它每次都会触发真实方法的调用 。简单来说就是用户更新缓存数据。但需要注意的是该注解的<code>value</code>
                                        和 <code>key</code> 必须与要更新的缓存相同，也就是与<code>@Cacheable</code> 相同。示例：</p>
                                    <pre class="prettyprint"><code class=" hljs cs">    @CachePut(<span
                                            class="hljs-keyword">value</span> = <span class="hljs-string">"emp"</span>, key = <span
                                            class="hljs-string">"targetClass + #p0"</span>)
    <span class="hljs-keyword">public</span> NewJob <span class="hljs-title">updata</span>(NewJob job) {
        NewJob newJob = newJobDao.findAllById(job.getId());
        newJob.updata(job);
        <span class="hljs-keyword">return</span> job;
    }

    @Cacheable(<span class="hljs-keyword">value</span> = <span class="hljs-string">"emp"</span>, key = <span
                                                class="hljs-string">"targetClass +#p0"</span>)<span
                                                class="hljs-comment">//清空缓存</span>
    <span class="hljs-keyword">public</span> NewJob <span class="hljs-title">save</span>(NewJob job) {
        newJobDao.save(job);
        <span class="hljs-keyword">return</span> job;
    }</code></pre>
                                    <p><strong>查看它的其它属性</strong></p>
                                    <pre class="prettyprint"><code class=" hljs scss">String<span
                                            class="hljs-attr_selector">[]</span> <span class="hljs-function">cacheNames()</span> <span
                                            class="hljs-value">default</span> {}; <span
                                            class="hljs-comment">//与value二选一</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> keyGenerator() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//key的生成器。key/keyGenerator二选一使用</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheManager() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//指定缓存管理器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheResolver() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//或者指定获取解析器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> condition() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span
                                            class="hljs-comment">//条件符合则缓存</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> unless() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//条件符合则不缓存</span></code></pre>
                                    <h3 id="6清除cacheevict">6.清除@CacheEvict</h3>
                                    <p><code>@CachEvict</code> 的作用 主要针对方法配置，能够根据一定的条件对缓存进行清空 。</p>
                                    <table>
                                        <thead>
                                        <tr>
                                            <th>属性</th>
                                            <th>解释</th>
                                            <th>示例</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td>allEntries</td>
                                            <td>是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存</td>
                                            <td>@CachEvict(value=&rdquo;testcache&rdquo;,allEntries=true)</td>
                                        </tr>
                                        <tr>
                                            <td>beforeInvocation</td>
                                            <td>是否在方法执行前就清空，缺省为 false，如果指定为
                                                true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存
                                            </td>
                                            <td>@CachEvict(value=&rdquo;testcache&rdquo;，beforeInvocation=true)</td>
                                        </tr>
                                        </tbody>
                                    </table>
                                    <p>示例：</p>
                                    <pre class="prettyprint"><code class=" hljs cs">    @Cacheable(<span
                                            class="hljs-keyword">value</span> = <span class="hljs-string">"emp"</span>,key = <span
                                            class="hljs-string">"#p0.id"</span>)
    <span class="hljs-keyword">public</span> NewJob <span class="hljs-title">save</span>(NewJob job) {
        newJobDao.save(job);
        <span class="hljs-keyword">return</span> job;
    }

    <span class="hljs-comment">//清除一条缓存，key为要清空的数据</span>
    @CacheEvict(<span class="hljs-keyword">value</span>=<span class="hljs-string">"emp"</span>,key=<span
                                                class="hljs-string">"#id"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
                                                class="hljs-title">delect</span>(<span class="hljs-keyword">int</span> id) {
        newJobDao.deleteAllById(id);
    }

    <span class="hljs-comment">//方法调用后清空所有缓存</span>
    @CacheEvict(<span class="hljs-keyword">value</span>=<span class="hljs-string">"accountCache"</span>,allEntries=<span
                                                class="hljs-keyword">true</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
                                                class="hljs-title">delectAll</span>() {
        newJobDao.deleteAll();
    }

    <span class="hljs-comment">//方法调用前清空所有缓存</span>
    @CacheEvict(<span class="hljs-keyword">value</span>=<span class="hljs-string">"accountCache"</span>,beforeInvocation=<span
                                                class="hljs-keyword">true</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span
                                                class="hljs-title">delectAll</span>() {
        newJobDao.deleteAll();
    }</code></pre>
                                    <p><strong>其他属性</strong></p>
                                    <pre class="prettyprint"><code class=" hljs scss">String<span
                                            class="hljs-attr_selector">[]</span> <span class="hljs-function">cacheNames()</span> <span
                                            class="hljs-value">default</span> {}; <span
                                            class="hljs-comment">//与value二选一</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> keyGenerator() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//key的生成器。key/keyGenerator二选一使用</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheManager() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>;  <span class="hljs-comment">//指定缓存管理器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> cacheResolver() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span class="hljs-comment">//或者指定获取解析器</span></code></pre>
                                    <pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-built_in">String</span> condition() <span
                                            class="hljs-keyword">default</span> <span
                                            class="hljs-string">""</span>; <span
                                            class="hljs-comment">//条件符合则清空</span></code></pre>
                                    <h3 id="7组合caching">7.组合@Caching</h3>
                                    <p>有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。</p>
                                    <pre class="prettyprint"><code class=" hljs r">    @Caching(cacheable = {
            @Cacheable(value = <span class="hljs-string">"emp"</span>,key = <span class="hljs-string">"#p0"</span>),
            <span class="hljs-keyword">...</span>
    },
    put = {
            @CachePut(value = <span class="hljs-string">"emp"</span>,key = <span class="hljs-string">"#p0"</span>),
            <span class="hljs-keyword">...</span>
    },evict = {
            @CacheEvict(value = <span class="hljs-string">"emp"</span>,key = <span class="hljs-string">"#p0"</span>),
            ....
    })
    public User save(User user) {
        ....
    }</code></pre>
                                    <p>下面讲到的整合第三方缓存组件都是基于上面的已经完成的步骤，所以一个应用要先做好你的缓存逻辑，再来整合其他cache组件。</p>
                                    <h2 id="五整合ehcache">五：整合EHCACHE</h2>
                                    <p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java
                                        EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP
                                        api等特点。</p>
                                    <h3 id="1导入依赖">1.导入依赖</h3>
                                    <p>整合ehcache必须要导入它的依赖。</p>
                                    <pre class="prettyprint"><code class=" hljs xml">        <span class="hljs-tag">&lt;<span
                                            class="hljs-title">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>net.sf.ehcache<span
                                                class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>ehcache<span
                                                class="hljs-tag">&lt;/<span
                                                class="hljs-title">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework.boot<span
                                                class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span
                    class="hljs-title">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span
                                                class="hljs-title">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre>
                                    <h3 id="2yml配置">2.yml配置</h3>
                                    <p>需要说明的是<code>config: classpath:/ehcache.xml</code>可以不用写，因为默认就是这个路径。但<code>ehcache.xml</code>必须有。
                                    </p>
                                    <pre class="prettyprint"><code class=" hljs lasso">spring:
  <span class="hljs-keyword">cache</span>:
    <span class="hljs-keyword">type</span>: ehcache
    ehcache:
      config: classpath:/ehcache<span class="hljs-built_in">.</span><span class="hljs-built_in">xml</span></code></pre>
                                    <h3 id="3ehcachexml">3.ehcache.xml</h3>
                                    <p>在resources目录下新建ehcache.xml，注释啥的应该可以说相当详细了</p>
                                    <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span
                                            class="hljs-title">ehcache</span>&gt;</span>

    <span class="hljs-comment">&lt;!--
        磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存
        path:指定在硬盘上存储对象的路径
        path可以配置的目录有：
            user.home（用户的家目录）
            user.dir（用户当前的工作目录）
            java.io.tmpdir（默认的临时目录）
            ehcache.disk.store.dir（ehcache的配置目录）
            绝对路径（如：d:\\ehcache）
        查看路径方法：String tmpDir = System.getProperty("java.io.tmpdir");
     --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">diskStore</span> <span class="hljs-attribute">path</span>=<span
            class="hljs-value">"java.io.tmpdir"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!--
        defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理
        maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象
        eternal:代表对象是否永不过期 (指定true则下面两项配置需为0无限期)
        timeToIdleSeconds:最大的发呆时间 /秒
        timeToLiveSeconds:最大的存活时间 /秒
        overflowToDisk:是否允许对象被写入到磁盘
        说明：下列配置自缓存建立起600秒(10分钟)有效 。
        在有效的600秒(10分钟)内，如果连续120秒(2分钟)未访问缓存，则缓存失效。
        就算有访问，也只会存活600秒。
     --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">defaultCache</span> <span class="hljs-attribute">maxElementsInMemory</span>=<span
            class="hljs-value">"10000"</span> <span class="hljs-attribute">eternal</span>=<span class="hljs-value">"false"</span>
                  <span class="hljs-attribute">timeToIdleSeconds</span>=<span class="hljs-value">"600"</span> <span
                class="hljs-attribute">timeToLiveSeconds</span>=<span class="hljs-value">"600"</span> <span
                class="hljs-attribute">overflowToDisk</span>=<span class="hljs-value">"true"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-title">cache</span> <span class="hljs-attribute">name</span>=<span
            class="hljs-value">"myCache"</span> <span class="hljs-attribute">maxElementsInMemory</span>=<span
            class="hljs-value">"10000"</span> <span class="hljs-attribute">eternal</span>=<span class="hljs-value">"false"</span>
                  <span class="hljs-attribute">timeToIdleSeconds</span>=<span class="hljs-value">"120"</span> <span
                class="hljs-attribute">timeToLiveSeconds</span>=<span class="hljs-value">"600"</span> <span
                class="hljs-attribute">overflowToDisk</span>=<span class="hljs-value">"true"</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">ehcache</span>&gt;</span></code></pre>
                                    <h3 id="4使用缓存">4.使用缓存</h3>
                                    <p><code>@CacheConfig(cacheNames = {&ldquo;myCache&rdquo;})</code>设置ehcache的名称，这个名称必须在ehcache.xml已配置
                                        。</p>
                                    <pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@CacheConfig</span>(cacheNames = {<span
                                            class="hljs-string">"myCache"</span>})
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span
                                                class="hljs-title">BotRelationServiceImpl</span> <span
                                                class="hljs-keyword">implements</span> <span class="hljs-title">BotRelationService</span> {</span>

    <span class="hljs-annotation">@Cacheable</span>(key = <span
                                                class="hljs-string">"targetClass + methodName +#p0"</span>)
    <span class="hljs-keyword">public</span> List&lt;BotRelation&gt; <span class="hljs-title">findAllLimit</span>(<span
                                                class="hljs-keyword">int</span> num) {
        <span class="hljs-keyword">return</span> botRelationRepository.findAllLimit(num);
    }

}</code></pre>
                                    <p>整合完毕！</p>
                                    <p>别忘了在启动类开启缓存！</p>
                                    <h2 id="六整合redis">六：整合Redis</h2>
                                    <p><strong>Redis 优势</strong></p>
                                    <ul>
                                        <li>性能极高 &ndash; Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
                                        <li>丰富的数据类型 &ndash; Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets
                                            数据类型操作。
                                        </li>
                                        <li>原子 &ndash;
                                            Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
                                        </li>
                                        <li>丰富的特性 &ndash; Redis还支持 publish/subscribe, 通知, key 过期等等特性</li>
                                    </ul>
                                    <h3 id="1启动redis">1.启动Redis</h3>
                                    <p>下载地址：<a href="https://github.com/MicrosoftArchive/redis/releases" rel="nofollow">https://github.com/MicrosoftArchive/redis/releases</a>
                                        <br/>
                                        <!-- <img title=""
                                              src="https://img-blog.csdn.net/20180715212453491?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1ZXNodXRvbmcxMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"
                                              alt="这里写图片描述"/>--></p>
                                    <h3 id="2导入依赖">2.导入依赖</h3>
                                    <p>就只需要这一个依赖！不需要<code>spring-boot-starter-cache</code></p>
                                    <pre class="prettyprint"><code class=" hljs xml">  <span class="hljs-tag">&lt;<span
                                            class="hljs-title">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework.boot<span
                                                class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span
                                                class="hljs-tag">&lt;/<span
                                                class="hljs-title">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre>
                                    <p>当你导入这一个依赖时，SpringBoot的CacheManager就会使用RedisCache。</p>
                                    <p>如果你的Redis使用默认配置，这时候已经可以启动程序了。</p>
                                    <h3 id="3配置redis">3.配置Redis</h3>
                                    <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-preprocessor"># Redis数据库索引（默认为0）</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.database</span>=<span
                                                class="hljs-number">1</span>
<span class="hljs-preprocessor"># Redis服务器地址</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.host</span>=<span
                                                class="hljs-number">127.0</span><span class="hljs-number">.0</span><span
                                                class="hljs-number">.1</span>
<span class="hljs-preprocessor"># Redis服务器连接端口</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.port</span>=<span
                                                class="hljs-number">6379</span>
<span class="hljs-preprocessor"># Redis服务器连接密码（默认为空）</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.password</span>=
<span class="hljs-preprocessor"># 连接池最大连接数（使用负值表示没有限制）</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.pool</span><span
                                                class="hljs-preprocessor">.max</span>-active=<span class="hljs-number">1000</span>
<span class="hljs-preprocessor"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.pool</span><span
                                                class="hljs-preprocessor">.max</span>-wait=-<span
                                                class="hljs-number">1</span>
<span class="hljs-preprocessor"># 连接池中的最大空闲连接</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.pool</span><span
                                                class="hljs-preprocessor">.max</span>-idle=<span
                                                class="hljs-number">10</span>
<span class="hljs-preprocessor"># 连接池中的最小空闲连接</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.pool</span><span
                                                class="hljs-preprocessor">.min</span>-idle=<span
                                                class="hljs-number">2</span>
<span class="hljs-preprocessor"># 连接超时时间（毫秒）</span>
spring<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.timeout</span>=<span
                                                class="hljs-number">0</span></code></pre>
                                    <h3 id="4模板编程">4.模板编程</h3>
                                    <p>除了使用注解，我们还可以使用Redis模板。 <br/>
                                        Spring boot集成 Redis 客户端jedis。封装Redis 连接池，以及操作模板。 </p>
                                    <pre class="prettyprint"><code class=" hljs java">    <span class="hljs-annotation">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<span class="hljs-comment">//操作key-value都是字符串</span>

    <span class="hljs-annotation">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<span
                                                class="hljs-comment">//操作key-value都是对象</span>

    <span class="hljs-javadoc">/**
     *  Redis常见的五大数据类型：
     *  stringRedisTemplate.opsForValue();[String(字符串)]
     *  stringRedisTemplate.opsForList();[List(列表)]
     *  stringRedisTemplate.opsForSet();[Set(集合)]
     *  stringRedisTemplate.opsForHash();[Hash(散列)]
     *  stringRedisTemplate.opsForZSet();[ZSet(有序集合)]
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(){
        stringRedisTemplate.opsForValue().append(<span class="hljs-string">"msg"</span>,<span class="hljs-string">"hello"</span>);
    }</code></pre>
                                </div>
                                <div id="MySignature"></div>
                                <div class="clear"></div>
                                <div id="blog_post_info_block">
                                    <div id="blog_post_info"></div>
                                    <div class="clear"></div>
                                    <div id="post_next_prev"></div>
                                </div>
                            </div>
                            <!-- <div class="postDesc">posted @
                                 <span id="post-date">2018-07-15 21:59</span>&nbsp;
                                 <a href="https://www.cnblogs.com/yueshutong/">卡布哒</a>&nbsp;
                                 阅读(<span id="post_view_count">...</span>)&nbsp;
                                 评论(<span id="post_comment_count">...</span>)&nbsp;
                                 <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9381540" rel="nofollow">编辑</a>&nbsp;
                                 <a href="javascript:void(0)" onclick="AddToWz(9381540);return false;">收藏</a></div>-->
                        </div>


                    </div><!--end: topics 文章、评论容器-->
                </div>
                <script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
                <script>markdown_highlight();</script>
                <script>
                    var allowComments = true, cb_blogId = 344744, cb_blogApp = 'yueshutong',
                        cb_blogUserGuid = 'd0f371ac-5d14-e711-845c-ac853d9f53ac';
                    var cb_entryId = 9381540, cb_entryCreatedDate = '2018-07-15 21:59', cb_postType = 1;
                    loadViewCount(cb_entryId);
                </script>
                <a name="!comments"></a>
                <div id="blog-comments-placeholder"></div>
                <script>
                    var commentManager = new blogCommentManager();
                    commentManager.renderComments(0);
                </script>

                <!--                <div id="comment_form" class="commentform">-->
                <!--                    <a name="commentform"></a>-->
                <!--                    <div id="divCommentShow"></div>-->
                <!--                    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);"-->
                <!--                                                                                 onclick="return RefreshCommentList();"-->
                <!--                                                                                 id="lnk_RefreshComments" runat="server"-->
                <!--                                                                                 clientidmode="Static">刷新评论</a><a-->
                <!--                            href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>-->
                <!--                    <div id="comment_form_container"></div>-->
                <!--                    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>-->
                <!--                    <div id="ad_t2"></div>-->
                <!--                    <div id="opt_under_post"></div>-->
                <!--                    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>-->
                <!--                    <script>-->
                <!--                        var googletag = googletag || {};-->
                <!--                        googletag.cmd = googletag.cmd || [];-->
                <!--                    </script>-->
                <!--                    <script>-->
                <!--                        googletag.cmd.push(function () {-->
                <!--                            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());-->
                <!--                            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());-->
                <!--                            googletag.pubads().enableSingleRequest();-->
                <!--                            googletag.enableServices();-->
                <!--                        });-->
                <!--                    </script>-->
                <!--                    <div id="cnblogs_c1" class="c_ad_block">-->
                <!--                        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>-->
                <!--                    </div>-->
                <!--                    <div id="under_post_news"></div>-->
                <!--                    <div id="cnblogs_c2" class="c_ad_block">-->
                <!--                        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">-->
                <!--                            <script>-->
                <!--                                if (new Date() >= new Date(2018, 9, 13)) {-->
                <!--                                    googletag.cmd.push(function () {-->
                <!--                                        googletag.display("div-gpt-ad-1539008685004-0");-->
                <!--                                    });-->
                <!--                                }-->
                <!--                            </script>-->
                <!--                        </div>-->
                <!--                    </div>-->
                <!--                    <div id="under_post_kb"></div>-->
                <!--                    <div id="HistoryToday" class="c_ad_block"></div>-->
                <!--                    <script type="text/javascript">-->
                <!--                        fixPostBody();-->
                <!--                        setTimeout(function () {-->
                <!--                            incrementViewCount(cb_entryId);-->
                <!--                        }, 50);-->
                <!--                        deliverAdT2();-->
                <!--                        deliverAdC1();-->
                <!--                        deliverAdC2();-->
                <!--                        loadNewsAndKb();-->
                <!--                        loadBlogSignature();-->
                <!--                        LoadPostCategoriesTags(cb_blogId, cb_entryId);-->
                <!--                        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);-->
                <!--                        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);-->
                <!--                        loadOptUnderPost();-->
                <!--                        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);-->
                <!--                    </script>-->
                <!--                </div>-->
            </div><!--end: forFlow -->
        </div><!--end: mainContent 主体内容容器-->

        <div id="sideBar">
            <div id="sideBarMain">

                <div class="newsItem" id="sidebar_news">
                    <script>loadBlogNews();</script>
                </div>

                <div id="blog-calendar" style="display:none"></div>
                <script>loadBlogDefaultCalendar();</script>

                <div id="leftcontentcontainer">
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                </div>

            </div><!--end: sideBarMain -->
        </div><!--end: sideBar 侧边栏容器 -->
        <div class="clear"></div>
    </div><!--end: main -->
    <div class="clear"></div>
    <!--    <div id="footer">-->
    <!--        &lt;!&ndash;done&ndash;&gt;-->
    <!--        Copyright &copy; 2020 卡布哒-->
    <!--        <br/><span id="poweredby">Powered by .NET Core 3.1.0 on Linux</span>-->


    <!--    </div>&lt;!&ndash;end: footer &ndash;&gt;-->
</div><!--end: home 自定义的最大容器 -->


<!--<div id="page_end_html">
    <script src="//files.cnblogs.com/files/yueshutong/readmore.min.js" defer></script>
    <script src="//files.cnblogs.com/files/yueshutong/reads.js" defer></script>
    <script type="text/javascript">
        $(document).ready(function () {
            readMoreOne('cnblogs_post_body')
        });
    </script>
</div>-->
</body>
</html>
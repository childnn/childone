lock: 当多个用户修改表中同一数据时, 可以给该行数据上锁(行锁).
    锁是在高并发下控制多个操作的顺序执行, 以此来保证数据安全的变动.
悲观锁: pessimistic concurrency control
    悲观锁认为被它保护的数据是极其不安全的, 每时每刻都有可能变动,
    一个事务拿到悲观锁后 (可以理解为一个用户), 其他任何事务都不能对该数据进行修改,
    只能等待锁被释放才可以执行.
    数据库中的行锁, 表锁, 读锁, 写锁, 以及 synchronized 实现的锁均为悲观锁
    MySQL 的常用引擎 innodb, 默认使用 行锁, 行锁是基于 索引 的, 因此要想加上 行锁
    在加锁时必须命中索引, 否则将使用表锁.
乐观锁: optimistic concurrency control
    乐观锁认为数据库中的数据变动不会太频繁, 因此, 它允许多个事务同时对数据进行变动
    乐观锁如何负责多个事务对数据进行修改?
    乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp) 来实现,
    其中, 版本最为常用.
    事务在从数据库中取数据时, 会将该数据的版本也取出来(v1), 当事务对数据变动完毕想要更新到表中时,
    会将之前取出的版本 v1 与数据库中最新的版本 v2 对比, 如果 v1 = v2, 那么说明在该事物操作数据期间,
    没有其他事务对数据进行修改(即数据版本没有变), 此时, 就允许事务对表中的数据进行修改,
    并且修改时 version 会加 1, 以此来表明数据已被变动.
    如果 v1 != v2, 那么说明数据变动期间, 数据被其他事务改动了, 此时不允许数据更新到表中,
    一般的处理办法是通知当前事务的用户重新操作.
    不同于悲观锁, 乐观锁是认为控制的.
mysql 悲观锁的使用:
  SQL:
    BEGIN;  # 开启事务: MySQL 默认自动提交
    SELECT column_name FROM table_name WHERE id = 1 FOR UPDATE;
    # 解释: 给表中 id = 1 的这条数据加上悲观锁, 只有当前事务可以对该条(行)数据 进行读写操作
    当 另一个事务也准备操作该表中 id = 1 的数据时(在另一个 (cmd)窗口中执行上述 sql 语句)
       可以看到上述语句执行会"卡住": 就是在等待前一个事务释放锁, 如果 锁 长时间没有被释放
       则等待获取锁的事务就会报错.
    COMMIT; # 修改完毕, 提交事务, 释放 行锁
    # 提交之后, 等待锁的事务窗口中出现了 查询字段(sql 中对应的字段)的信息
乐观锁的使用: (使用 version 版本号的方式)
    给目标表加上一个 version 字段
    基本原理: 认为数据修改产生冲突的概率不太大, 多个事务修改数据之前查出版本号, 在修改时把
    当前版本号作为修改条件, 只会有一个事务可以修改成功, 其他事务会失败.
    A 和 B 同时操作同一条数据, A 修改数据提交后, 对应数据的版本号会 +1
    此时, B 会修改失败.
  SQL:
    BEGIN; # 开启事务
    SELECT column_name, version FROM table_name WHERE id = 1;
    # A, B 执行相同操作, 获取到相同的结果
    UPDATE table_name SET column_name = column_name - 1, version = version + 1 WHERE id = 1;
    # A 更新数据, 版本号
    # B 再执行相同 sql, 会发现修改行数为 0 (可以根据业务逻辑提示用户重新提交..)
比较:
    悲观锁:
        优点: 利用数据库锁机制, 实现数据变化的 顺序执行, 这是最有效的办法
        缺点: 效率低, 影响并发, 吞吐量
    乐观锁:
        优点: 不再数据库加锁, 任何事务都可以对数据进行操作, 再更新提交时, 才进行校验
            这样就避免了悲观锁造成的 吞吐量下降的问题.
        缺点: 乐观锁是认为实现, 仅用于自己的业务中, 如果有外来事务插入, 就可能发生错误
总结:
    悲观锁 由于吞吐量性能问题, 适合 写 操作多的情况
    乐观锁 使用与 读 操作多的情况.

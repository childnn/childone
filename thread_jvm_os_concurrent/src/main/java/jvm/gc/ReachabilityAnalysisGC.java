package jvm.gc;

/**
 * ~~ Talk is cheap. Show me the code. ~~ :-)
 *
 * @author MiaoOne
 * @since 2020/5/21 16:13
 * 可达性分析算法:
 * 主流的商用程序语言(Java, C#, 甚至包括古老的 Lisp)的主流实现中, 都是称通过可达性分析
 * Reachability Analysis 来判定对象是否存活的.
 * 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下
 * 搜索, 搜索所走过的路径称为 引用链(Reference Chain), 当一个对象到 GC Roots 没有任何引用链
 * 相连(用图论的话来说, 就是从 GC Roots 到这个对象不可达)时, 则证明此对象是不可用的.
 * 在 Java 语言中, 可作为 GC Roots 的对象包括下面几种:
 * 虚拟机栈(栈帧中的本地变量表)中引用的对象.
 * 方法区中类静态属性引用的对象.
 * 方法区中常量引用的对象.
 * 本地方法栈中 JNI(Java Native Interface 本地方法) 引用的对象.
 * ------------------------------------------------------
 * 无论通过引用计数算法判断对象的引用数量, 还是通过可达性分析算法判断对象的引用链是否可达, 判定对象是否存活
 * 都与 "引用" 有关. 在 JDK 1.2 之前, Java 中的引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的
 * 是另外一块内存的起始地址, 就称这块内存代表着一个引用. 这种定义很纯粹, 但是太过狭隘, 一个对象在这种定义下
 * 只有被引用或者没有被引用两种状态, 对于如何描述一些 "食之无味弃之可惜" 的对象就显得无能为力了.
 * 我们希望能描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张,
 * 则可以抛弃这些对象.
 * 在 JDK 1.2 之后, Java 对引用的概念进行了扩充, 将引用分为 强引用(Strong Reference), 软引用(Soft Reference),
 * 弱引用(Weak Reference), 虚引用(Phantom Reference)
 * 强引用就是指在程序中普遍存在的, 类似 "Object obj = new Object()" 这类的引用, 只要强引用还存在, 垃圾收集器永远不会
 * 回收掉被引用的对象.
 * 软引用是用来描述一些还有用但并非必需的对象. 对于软引用关联着的对象, 在系统将要发生内存溢出异常之前, 将会把这些
 * 对象列进回收范围之中进行第二次回收. 如果这次回收还没有足够的内存, 才会抛出内存溢出异常.
 * 弱引用也是用来描述非必需对象的, 但是它的强度比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前.
 * 当垃圾收集器工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象.
 * 虚引用也称为幽灵引用或者幻影引用, 它是最弱的一种引用关系. 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响,
 * 也无法通过虚引用取得一个对象实例. 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知.
 */
public class ReachabilityAnalysisGC {

}

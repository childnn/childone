    深入理解 Java 虚拟机
程序计数器: Program Counter Register
    一块较小的内存空间, 它可以看作是当前线程所执行的字节码的行号指示器.
    在虚拟机的概念模型里(仅是概念模型, 各种虚拟机可能会通过一些更高效的方式去实现),
    字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,
    分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,
    在任何一个确定的时刻, 一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的
    指令. 因此, 为了线程切换后能回复到正确的执行位置, 每条线程都需要有一个独立的
    程序计数器, 各条线程之间计数器互不影响, 独立存储, 称这类内存区域为 "线程私有" 的内存.
    如果线程正在执行的是一个 Java 方法, 这个计数器记录的是正在执行的虚拟机字节码指令
    的地址: 如果正在执行的是 Native 方法, 这个计数器值则为空(Undefined).
    此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域.
Java 虚拟机栈: Java Virtual Machine Stacks
    与程序计数器一样, Java 虚拟机栈也是线程私有的, 它的生命周期与线程相同. 虚拟机栈描述
    的是 Java 方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧(Stack Frame) 用于存储
    局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着
    一个栈帧在虚拟机中入栈到出栈的过程。
    局部变量表存放了编译器可知的各种基本数据类型, 对象引用, returnAddress 类型(指向了一条字节码指令的地址).
    在 Java 虚拟机规范中, 对这个区域规定了两种异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度,
    将抛出 StackOverflowError 异常: 如果虚拟机栈可以动态扩展(当前大部分的 Java 虚拟机都可动态扩展,
    只不过Java 虚拟机规范中也允许固定长度的虚拟机栈), 如果扩展时无法申请到足够的内存, 就会抛出 OutOfMemoryError 异常.
本地方法栈: Native Method Stack
    与虚拟机栈所发挥的作用非常相似, 区别不过是 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务, 而本地方法栈
    为虚拟机使用的 Native 方法服务.
Java 堆: Java Heap
    Java 堆是 Java 虚拟机所管理的内存中最大的一块. Java 堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建.
    此区域的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存. 这一点在 Java 虚拟机规范中的描述是:
    所有的对象实例以及数组都要在堆上分配-- The heap is the runtime data area from which memory for all class
    instances and arrays is allocate.
    Java 堆是垃圾收集器管理的主要区域, 因此很多时候也被称作 "GC 堆"(Garbage Collated Heap).
    从内存分配的角度来看, 线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB).
    通过 -Xmx 和 -Xms 控制堆空间, 如果在堆中没有内存完成实例分配, 并且堆也无法在扩展时, 将会抛出 OutOfMemoryError 异常.
方法区 Method Area
    与 Java 堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据。
     "java.lang.OutOfMemoryError: PermGen space ", 这里的 “PermGen space”其实指的就是方法区。
     不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，
     并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM）
     并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。
     在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间）.
     JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中.
     元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
     因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
     　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：
            如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
     　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
     　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
     　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
     　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
     由 方法区 到 原空间转换的理由:
         1、字符串存在永久代中，容易出现性能问题和内存溢出。
     　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
     　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
     　　4、Oracle 可能会将HotSpot 与 JRockit 合二为一。
     HotSpot 虚拟机的设计团队选择把 GC 分代扩展至方法区, 或者说使用永久代来实现方法区, 这样 HotSpot 的垃圾收集器可以像
     管理 Java 堆一样管理这部分内存, 能够省去专门为方法区编写内存管理代码的工作.
运行时常量池: Runtime Constant Pool
    方法区的一部分. Class 文件中除了有类的版本、字段、方法、接口等描述信息外, 还有一项信息是常量池, 用于存放编译期生成的
    各种字面量和符号引用, 这部分内容将在类加载后进入方法区的运行时常量池中存放.
    运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性, Java 语言并不要求常量一定只有编译期才能产生,
    也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入池中, 这种特性被
    开发人员利用的比较多的便是 String 类的 intern() 方法.
直接内存: Direct Memory
    并不是虚拟机运行时数据区的一部分, 也不是 Java 虚拟机规范中定义的内存区域. 但是这部分内存也被频繁地使用, 而且也可能导致
    OOM 异常的出现.
    JDK 1.4 中引入的 NIO, 有一种基于通道 Channel 与缓冲区 Buffer 的 I/O 方式, 它可以使用 Native 函数库直接分配堆外内存,
    然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作. 这样能在一些场景中显著提高性能,
    因为避免了在 Java 堆和 Native 堆中来回复制数据.

程序计数器, 虚拟机栈, 本地方法栈 3 个区域随着线程而生/灭.
这几个区域内不需要过多考虑回收的问题, 因为方法或者线程结束时, 内存自然就回收了.
Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支
则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存
也可能不一样, 只有在程序运行期间才能知道会创建哪些对象, 这部分内存的分配和回收都是动态的, 垃圾收集器所关注
的是这部分内存.

判断对象是否存活: 引用计数算法, 可达性分析算法
垃圾收集算法: 标记-清除算法, 复制算法, 标记-整理算法, 分代收集算法
 标记-清除: Mark-Sweeping
    算法分为 "标记", "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后同意回收所有被标记的对象,
    它的标记过程其实就是判定对象的引用问题(可达性分析算法). 它主要有两个不足点: 一个是效率问题, 标记和清除
    两个过程的效率都不高; 另一个是空间问题, 标记清楚后会产生大量不连续的内存碎片, 空间碎片大多可能会导致以后
    在程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作.
 复制算法: Copying
    为了解决效率问题, 复制收集算法出现, 它将可用内存按容量划分为大小相等的两块, 每次使用其中一块. 当这一块内存用完了,
    就将还存活的对象复制到另一块上, 然后再把已使用过的内存空间一次清理掉. 这样使得每次都是对整个半区进行内存回收,
    内存分配时也就不用考虑内存碎片等复杂情况, 只要移动堆顶指针, 按顺序分配内存即可, 实现简单, 运行高效.
    只是这种算法的代价是将内存缩小为原来的一半.

类从被加载到虚拟机内存中开始, 到卸载出内存为止, 它的整个生命周期包括:
    加载 Loading -- ||验证 Verification -- 准备 Preparation -- 解析 Resolution|| -- 初始化 Initialization
    -- 使用 Using -- 卸载 Unloading
    其中 验证 准备 解析 3 部分统称为 链接 Linking
    加载 是根据特定名称查找类或接口类型的二进制表示（binary representation），并由此二进制表示来创建类或接口的过程。
    链接 是为了让类或接口可以被 Java 虚拟机所执行，而将类或接口并入虚拟机运行时状态的过程。
    类或接口的初始化是指执行类或接口的初始化方法 <clinit>.
    -------
    加载, 验证, 准备, 初始化, 卸载 5 阶段的顺序是确定的, 类的加载过程必须按照这种顺序按部就班的开始,
    而解析阶段则不一定: 在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定(动态绑定/晚期绑定).
  Java 虚拟机规范允许灵活地选择链接(及由于递归链接而引发地加载)时机,但必须保证下列几点成立:
  1) 在类或接口被链接之前,它必须被成功地加载过.
  2) 在类或接口初始化之前,他必须被成功地验证及准备过.
  3) 若程序执行了某种可能需要直接或间接链接一个类或接口的动作, 而在链接该类或接口的过程中又检测到了错误,
    则错误的抛出点应该是执行动作的那个点.
  对于初始化阶段, 虚拟机规范严格规定了有且只有 5 种情况必须立即对类进行 "初始化" (而加载, 验证, 准备自然需要在此之前进行):
  1) 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令时, 如果类没有进行过初始化, 则需要先出发其初始化.
    生成这四条指令的最常见 Java 代码场景是: 使用 new 关键字实例化对象的时候, 读取或设置一个类的静态字段(被 final 修饰、
    已在编译期把结果放入常量池的静态字段除外) 的时候, 以及调用一个类的静态方法的时候.
  2) 使用 java.lang.reflect 包的方法对类进行反射调用的时候, 如果类没有进行过初始化, 则需要先触发其初始化.
  3) 当初始化一个类的时候, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化.
  4) 当虚拟机启动时, 用户需要指定一个要执行的主类(包含 main() 方法的那个类), 虚拟机会先初始化这个主类.
  5) 当使用 JDK 1.7 的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic,
    REF_putStatic, REF_invokeStatic 的方法句柄, 并且这个方法句柄所对应的类没有进行过初始化, 则需要先出发其初始化.
 ---
 虚拟机启动
    Java 虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的,这个类是由虚拟机的具体
    实现指定的. 紧接着,Java 虚拟机链接这个初始类,初始化它并调用它的 public 方法 void main(String[]). 之后的整个执行过程都是
    由对此方法的调用开始的. 执行 main 方法中的 Java 虚拟机指令可能会导致 Java 虚拟机链接(并于其后创建)另外的一些类或接口,
    也可能会令虚拟机调用另外的方法.
    在某种 Java 虚拟机的实现上,初始类可能会作为命令行参数(command line argument)提供给虚拟机. 当然,虚拟机实现也可以令初始类
    设定类加载器,并且用这个加载器一次加载整个应用. 另外,在遵循上一段所述规范的前提下,也可以选用其他形式的初始类.
 ---
 创建和加载
   如果要创建标记为 N 的类或接口 C,就需要先在 Java 虚拟机方法区上为 C 创建与虚拟机实现相匹配的内部表示. C 的创建是由另外一个
   类或接口 D 所触发的,它通过自己的运行时常量池引用了 C. 当然, C 的创建也可能是由 D 调用 Java SE 平台类库中的某些方法而触发,
   譬如使用反射等.
   如果 C 不是数组类,那么它可以通过类加载器加载 C 的二进制表示来创建. 数组没有外部的二进制表示;它们都是由 Java 虚拟机创建的,
   而不是通过类加载器加载的.
   Java 虚拟机支持两种功类加载器: Java 虚拟机提供的引导类加载器和用户自定义的类加载器. 每个用户自定义的类加载器应该是抽象类
   ClassLoader 的某个子类的实例. 应用程序使用用户自定义加载器是为了便于扩展 Java 虚拟机的功能, 以支持动态加载并创建类. 当然,
   它也可以从用户自定义的数据来源获取类的二进制表示并创建类. 例如,用户自定义类加载器可以通过网络下载,动态产生或从一个加密文件中
   提取类的信息.
   类加载器 L 可能会通过直接定义或委托其他类加载器的方法来创建 C. 如果 L 直接创建 C, 就可以说 L 定义了(define) C, 或者,
   L 是 C 的定义加载器(define loader).
   当一个类加载器把加载请求委托给其他的类加载器后,发出这个加载请求的加载器与最终完成加载并定义类的类加载器不需要是同一个加载器.
   如果 L 创建了 C, 那么它可能是通过直接定义的方式,或是委托其他加载器的方式来创建 C 的,可以说 L 导致了(initiate) C 的加载,
   或者, L 是 C 的初始加载器(initiating loader).
   在 Java 虚拟机运行时,类或接口不仅仅是由它的名称来确定,而是由一个值对: 二进制名称和它的定义类加载器共同确定的. 每个这样的
   类或接口都只属于一个而运行时包结构(runtime package). 类或接口的运行时包结构由包名及类或接口的定义类加载器来决定.
   Java 虚拟机通过下面三个过程之一来创建标记为 N 的类或接口 C:
   -- 如果 N 表示一个非数组的类或接口,那么可以用下面的方法之一来加载并创建 C:
     - 如果 D 是由引导类加载器所定义的,那么用引导类加载器初始加载 C.
     - 如果 D 是由用户自定类加载器所定义的,那么就用这个用户自定义类加载器来初始加载 C.
   -- 如果 N 表示一个数组类,那么该数组类是由 Java 虚拟机而不是类加载器创建的. 然而,在创建数组类 C 的过程中,
      也会用到 D 的定义类加载器.
   请注意: 一个功能良好的类加载器应当保证下面三个属性:
     - 给定相同的名称,类加载器应当总是返回相同的 Class 对象.
     - 如果类加载器 L1 将加载类 C 的请求委托给另外的类加载器 L2,那么对于满足下列条件之一的任意类型 T 来说, L1 和 L2 都
       应当返回相同的 Class 对象: T 是 C 的直接超类或直接超接口; T 是 C 中某个字段的类型; T 是 C 中某个方法或构造器的
       形式参数类型, T 是 C 中某个方法的返回值类型.
     - 如果某个用户自定义的类加载器预先加载了某个类或接口的二进制表示,或批量加载了一组相关的类,并在加载时出现错误,那它就
       必须在程序的某个点反应出加载时的错误.而这个点,一定要和不使用预先加载或批量加载时出现错误的那个点相同.

 ---
 加载 loading
    在加载阶段, 虚拟机需要完成以下 3 件事情:
    1) 通过一个类的全限定名来获取定义此类的二进制字节流
    2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    3) 在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问入口
 验证 verification
    验证是连接阶段的第一步, 这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求, 并且
    不会危害虚拟机自身的安全.
    1) 文件格式验证
      第一阶段要验证字节流是否符合 Class 文件格式的规范, 并且能被当前版本的虚拟机处理. 这一阶段可能包括下面
      这些验证点:
      是否以魔数 0xCAFABABE 开头
      主、次版本号是否在当前虚拟机处理范围之内
      常量池的常量中是否有不被支持的常量类型
      指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
      CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据
      Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息
      ......etc
    只有经过验证后, 字节流才会进入内存的方法区中进行存储, 后面 3 个验证阶段全部是基于方法区的存储结构进行的,
    不会再直接操作字节流.
    2) 元数据验证
      第二阶段是对字节码描述的信息进行语义分析, 以保证其描述的信息符合 Java 语言规范的要求, 这个阶段可能包括的
      验证点如下:
      这个类是否有父类(除了 java.lang.Object 之外, 所有的类都应当有父类)
      这个类的父类是否继承了不允许被继承的类(被 final 修饰的类)
      如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法
      类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的 final 字段, 或者出现不符合规则的方法重载,
       例如方法参数都一致, 但返回值类型却不同等)
      ... etc
    3) 字节码验证
      第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是通过数据流和控制流分析, 确定程序语义是合法的, 符合逻辑的.
      在第二阶段对元数据信息中的数据类型做完校验后, 这个阶段将对类的方法体进行校验分析, 保证被校验类的方法在运行时
      不会做出危害虚拟机安全的事件.
      例如:
      保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作, 例如不会出现类似这样的情况: 在操作栈放置了一个 int
        类型的数据, 使用时却按 long 类型来加载入本地变量表中.
      保证跳转指令不会跳转到方法体以外的字节码指令上
      保证方法体中的类型转换是有效的, 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给
      子类数据类型, 甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型, 则是危险和不合法的
      ... etc
    4) 符号引用验证
      最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三阶段 -- 解析阶段
      发生. 符号引用验证可以看作是对类自身以外(常量池中的各种符号引用) 的信息进行匹配性校验, 通常需要校验下列内容:
      符号引用中通过字符串描述的全限定名是否能找到对应的类
      在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
      符号引用中的类、字段、方法的访问性(四种访问权限)是否可以被当前类访问
      符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 那么将会抛出 java.lang.IncompatibleClassChangeError
      异常的子类, 如 java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等
 准备 preparation
    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段, 这些变量所使用的内存都将在方法区进行分配.
    这时候进行内存分配的仅包括类变量(被 static 修饰的变量), 而不包括实例变量, 实例变量将会在对象实例化时随着对象
    一起分配在 java 堆中. 这里所说的 初始值 "通常情况" 是数据类型的 零值(默认值)
    假设一个类变量的定义为: public static int value = 123;
    那么 value 在准备阶段过后的初始值为 0 而不是 123. 因为这时候尚未开始执行任何 java 方法, 而把 value 赋值为 123
    的 putstatic 指令是程序被编译后, 存放于类构造器 <clinit>() 方法之中, 所以把 value 赋值为 123 的动作将在
    初始化阶段才会执行.
    在 "通常情况" 下初始值是 零值, 相对会有一些 "特殊情况": 如果类字段的属性表中存在 ConstantValue, 那在准备
    阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值
    假设上面的类变量定义为: public static final int value = 123;
    编译时 Javac 将会为 value 生成 ConstantValue 属性, 在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123.
 解析 resolution
    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程.
    符号引用 Symbolic References: 符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能
       无歧义地定位到目标即可. 符号引用与虚拟机实现的内存布局无关, 引用的目标并不一定已经加载到内存中. 各种虚拟机
       实现的内存布局可以各不相同, 但是它们能接受的符号引用必须都是一致的, 因为符号引用的字面量形式明确定义在 Java
       虚拟机规范的 Class 文件格式中.
    直接引用 Direct References: 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
       直接引用是和虚拟机实现的内存布局相关的, 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同.
       如果有了直接引用, 那引用的目标必定已经在内存中存在.
 初始化
    类初始化阶段是类加载过程的最后一步, 前面的类加载过程中, 除了在加载阶段用户应用程序可以通过自定义类加载器参与之外,
    其余动作完全由虚拟机主导和控制. 到了初始化阶段, 才真正开始执行类中定义的 Java 程序代码(字节码).
    在准备阶段, 变量已经赋值过一次系统要求的初始值, 而在初始化阶段, 则根据程序员通过程序指定的主观计划去初始化类变量
    和其他资源, 或者可以从另外一个角度来表达: 初始化阶段是执行类构造器 <clinit>() 方法的过程.
    <clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{} 块)中的语句合并产生的, 编译器收集
       的顺序是由语句在源文件中出现的顺序所决定的, 静态语句块中只能访问到定义在静态语句块之前的变量, 定义在它之后的变量,
       在前面的静态语句块可以赋值, 但是不能访问.
    <clinit>() 方法与类的构造函数(实例构造器 <init>() 方法)不同, 它不需要显示地调用父类构造器, 虚拟机会保证在子类的 <clinit>()
       方法执行之前, 父类的 <clinit>() 方法已经执行完毕. 因此在虚拟机中第一个被执行的 <clinit>() 方法的类肯定是 java.lang.Object.
       由于父类的 <clinit>() 方法先执行, 也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作.
    <clinit>() 方法对于类或接口来说并不是必须的, 如果一个类中没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成
       <clinit>() 方法
    接口中不能使用静态语句块, 但仍然有变量初始化的赋值操作, 因此接口与类一样都会生成 <clinit>() 方法. 但接口与类不同的是,
       执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法. 只有当父接口中定义的变量使用时, 父接口才会初始化.
       另外, 接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法.
    虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确地加锁、同步, 如果多个线程同时初始化一个类, 那么只会有一个线程去执行这个类的
       <clinit>() 方法, 其他线程都需要阻塞等待, 直到活动线程执行 <clinit>() 方法完毕. 如果在一个类地 <clinit>() 方法中
       有耗时很长地操作, 就可能造成多个线程阻塞.
       参见本项目下的示例类: jvm.classloading.DeadLoopClass
       需要注意, 其他线程虽然会被阻塞, 但如果执行 <clinit>() 方法的那条线程退出 <clinit>() 方法的那条线程退出 <clinit>()
       方法后, 其他线程唤醒之后不会再次进入 <clinit>() 方法. 同一个类加载器下, 一个类型只会初始化一次.
-----------------------------------
栈帧: Stack Frame
    用于支持虚拟机进行方法调用和方法执行的数据结构, 它是虚拟机运行时数据区中的虚拟机栈 Virtual Machine Stack 的栈元素.
    栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。 每个方法从调用开始至执行完成的过程，都对应着一个
    栈帧在虚拟机里从入栈到出栈的过程。
    每个栈帧都包括 局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大
    的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此一个栈帧需要分配多少内存，不会受到
    程序运行期变量数据的影响，而且仅仅却决于具体的虚拟机实现。
    一个线程中哦的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧
    才是有效的，称为 当前栈帧 Current Stack Frame，与这个栈帧相关联的方法称为 当前方法 Current Method。执行引擎运行的所有
    字节码指令都只针对当前栈帧进行操作。
    局部变量表：Local Variable Table
      一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译为 class 文件时，就在方法的 Code 属性
      的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量.
      局部变量表的容量以 变量槽 Variable Slot 为最小单位, 虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小, 只是
      很有向导性的说到每个 Slot 都应该能存放一个 boolean, byte, char, short, int, float, reference, returnAddress 类型的
      数据, 这 8 种数据类型, 都可以使用 32 位或更小的物理内存来存放, 但这种描述与明确指出 '每个 Slot 占用 32 位长度的内存空间'
      有一些差别, 它允许 Slot 的长度可以随着处理器, 操作系统或虚拟机的不同而发生变化. 只要保证即使在 64 位虚拟机种使用了
      64 位的物理内存空间去实现一个 Slot, 虚拟机仍要使用对其和补白的手段让 Slot 在外观上看起来与 32 位虚拟机中的一致.
    操作数栈 Operand Stack
       常称 操作栈, 它是一个后入先出 Last In First Out, LIFO 栈. 同局部变量表一样, 操作数栈的最大深度也在编译的时候写入到
       Code 属性的 max_stacks 数据项中. 操作数栈的每一个元素可以是任意的 Java 数据类型.
       当一个方法刚刚开始执行的时候,这个方法的操作数栈是空的,在方法的执行过程中,会有各种字节码指令往操作数栈中写入和提取
       内容,也就是 出栈/入栈 操作.
    动态连接 Dynamic Linking
       每个栈帧都包含一个指向运行时常量池中改栈帧所属方法的引用,持有这个引用是为了支持方法调用过程中的 动态连接.
       class 文件的常量池中存在大量的符号引用,字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数.
       这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用,这种转化称为 静态解析. 另外一部分将在每次运行
       期间转化为直接引用, 这部分称为 动态连接.
    方法返回地址
       当一个方法开始执行后,只有两种方式可以退出这个方法. 第一种方式是执行引擎遇到任意一个方法返回的字节码指令, 这时候
       可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为 调用者), 是否有返回值和返回值的类型将根据遇到何种方法
       方法返回指令来决定,这种退出方法的方式称为 正常完成出口 Normal Method Invocation Completion.
       另外一种退出方式是,在方法执行过程中遇到了异常,并且这个异常没有在方法体内得到处理,无论是 Java 虚拟机内部产生的异常,
       还是代码中使用 athrow 字节码指令产生的异常,只要在本方法的异常表中没有搜索到匹配的异常处理器,就会导致方法退出,
       这种退出方法的方式称为异常完成 Abrupt Method Invocation Completion.

动态类型语言:
    类型检查的主体过程在运行期而不是编译期。
    APL,Clojure,Erlang,Groovy,JavaScript,Jython,Lua,PHP,Prolog,Python,Ruby,Smalltalk,Tcl等。
静态类型语言:
    在编译期就进行类型检查过程的语言。C++, Java
静态语言严谨，动态语言灵活
JDK 1.7 中 invokedynamic 指令以及 java.lang.invoke 包的引入，提供了动态类型的技术支持。
invoke 包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式之外，提供一种新的动态确定目标方法
的机制，称为 MethodHandle。Java 无法使用函数指针，把函数作为参数
  void sort(int list[], const int size, int(*compare)(int, int)); // C/C++
 Java 无法做到这一点，普遍的做法是设计一个带有 compare() 方法的 Comparator 接口。
在拥有了 Method Handle 之后，Java 也可以拥有类似函数指针或者委托的方法别名的工具了。

Java 中线程的 5 中状态:
    New: 创建后尚未启动
    Runnable: 包括操作系统线程状态的 Running 和 Ready, 也就是处于此状态的线程有可能正在执行,也有可能正在等待 CPU 为它分配时间
    Waiting: 处于这种状态的线程不会被分配 CPU 执行时间, 它们要等待被其他线程显式地唤醒.
         以下方法会让线程陷入无限期等待状态
         1. 没有设置 Timeout 参数地 Object.wait() 方法
         2. 没有设置 Timeout 参数地 Thread.join() 方法
         3. LockSupport.park() 方法.
    Timed Waiting: 处于这种状态的线程也不会被分配 CPU 执行时间, 不过无须等待被其他线程显式地唤醒,在一定时间之后会由
        系统自动唤醒. 以下方法会让线程进入限期等待状态:
        1. Thread.sleep() 方法
        2. 设置了 Timeout 参数的 Object.wait() 方法
        3. 设置了 Timeout 参数的 Thread.join() 方法
        4. LockSupport.parkNanos() 方法
        5. LockSupport.parkUntil() 方法
    Blocked: 线程被阻塞了, "阻塞状态" 与 "等待状态" 的区别是: "阻塞状态" 在等待获取到一个排他锁, 这个事件将在另外一个线程
        放弃这个锁的时候发生; 而 "等待状态" 则是在等待一段时间, 或者唤醒动作的发生. 在程序等待进入同步区域的时候, 线程将进入这种状态.
    Terminated: 已终止线程的线程状态,线程已经结束执行.

---------------------------- Java 虚拟机规范 -------------------------------------------------
Java 虚拟机中有三种引用类型: 类类型(class type),数组类型(array type),接口类型(interface type).
这些引用类型的值分别指向动态创建的类实例,数组实例和实现了某个接口的类实例或数组实例.
数组类型最外面那一维的类型(此维度的长度不由数组类型来决定),叫做该数组类型的 组件类型(component type).
一个数组的组件类型也可以是数组.从任意一个数组开始,如果发现其组件类型也是数组类型,那就继续取这个小数组的组件类型,
不断执行这样的操作,最终一定可以遇到组件类型不是数组的情况,这是就把这种类型称为本数组类型的 元素类型(element type).
数组的元素类型必须是 原始类型,类类型,或接口类型之一.

运行时数据区
    Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区,其中有一些会随着虚拟机启动而创建,虽则虚拟机退出而销毁.
    另外一些则是与线程一一对应的,这些与线程对应的数据区域会随着线程开始和结束而创建和销毁.
1. 寄存器:
    每一条 Java 虚拟机线程都有自己的 pc(program counter)寄存器. 在任意时刻,一条 Java 虚拟机线程只会执行一个方法的代码,
    这个正在被线程执行的方法称为该线程的当前方法(current method). 如果这个方法不是 native 的,那 pc 寄存器 就保存 Java
    虚拟机正在执行的字节码指令的地址,如果该方法是 native 的, 那 pc 寄存器的值是 undefined.
2. Java 虚拟机栈
    每条 Java 虚拟机线程都有自己私有的 Java 虚拟机栈(Java Virtual Machine stack), 这个栈与线程同时创建,用于存储栈帧(Frame).
    Java 虚拟机栈的作用与传统语言(如 C 语言)中的栈非常相似,用于存储局部变量与一些尚未算好的结果. 另外,它在方法调用和返回中
    也扮演了很重要的角色.因为除了栈帧的出栈和入栈之外,Java 虚拟机栈不会再受其他因素的影响,所以栈帧可以在堆中分配,Java 虚拟机
    所使用的内存不需要保证是连续的.
        注: 避免混淆 Stack, Heap, Java (VM) Stack, Java Heap 的概念,Java 虚拟机的实现本质上是由其他语言所编写的应用程序,Java 语言
        程序里分配在 Java Stack 中的数据,从实现虚拟机的程序角度上看则可能分配在 Heap 之中.
    Java 虚拟机规范既允许 Java 虚拟机栈被实现成固定大小,也允许根据计算动态来扩展和收缩. 如果采用固定大小的 Java 虚拟机栈,
    那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定.
    Java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段,对于可以动态扩展和收缩 Java 虚拟机栈来说,则应当
    提供调节其最大,最小容量的手段.
    Java 虚拟机栈可能发生如下异常情况:
      1. 如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量,Java 虚拟机将会抛出 StackOverflowError.
      2. 如果 Java 虚拟机栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去
        创建对应的虚拟机栈,那 Java 虚拟机将会抛出 OutOfMemoryError.
3. Java 堆
    在 Java 虚拟机中,堆(heap)是可供各个线程共享的运行时内存区域,也是供所有实例和数组对象分配内存的区域.
    Java 堆在虚拟机启动的时候就被创建,它存储了被 自动内存管理系统(automatic storage management system, 也即常说的
    garbage collector 垃圾收集器) 所管理的各种对象,这些受管理的对象无需也无法显示的销毁. 本规范中所描述的 Java 虚拟机
    并未假设采用何种具体技术去实现自动内存管理系统. 虚拟机实现者可以根据系统的实际需要来选择自动内存管理技术. Java 堆
    的容量可以是固定的,也可以是随着程序执行的需求动态扩展,并在不需要过多空间时自动收缩. Java 堆所使用的内存不需要保证是连续的.
    Java 虚拟机实现应当提供给程序员或者最终用户调节 Java 堆初始容量的手段,对于可以动态扩展和收缩的 Java 堆来说,则应当提供
    调节其最大,最小容量的手段.
    Java 堆可能发生如下异常:
      如果实际所需的堆超过了自动内存管理系统所能提供的最大容量,那 Java 虚拟机将会抛出 OutOfMemoryError.
4. 方法区
    在 Java 虚拟机中,方法区(method area)是可供各个线程共享的运行时内存区域. 方法区与传统语言中的编译代码存储区
    (storage area for compiled code)或者操作系统进程的正文段(text segment)的作用非常类似, 它存储了每个类的结构信息,
    例如, 运行时常量池(runtime constant pool),字段和方法数据,构造函数和普通方法的字节码内容,还包括一些在类,实例,接口初始化
    时用到的特殊方法.
    方法区在虚拟机启动的时候创建,虽然方法区是堆的逻辑组成部分,但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩.
    注: JDK 1.8 以后, 方法区的实现方式已经变化: 永久代改为元空间(具体的内容还需要深入学习).
    方法区内存不能满足内存分配请求,那么 Java 虚拟机将抛出一个 OutOfMemoryError.
5. 运行时常量池
    runtime constant pool 是 class 文件中每个类或接口的常量池表(constant_pool table)的运行时表示形式,它包括了若干种不同的
    常量,从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用. 运行时常量池类似传统语言的 符号表(symbol table),
    不过它存储数据的范围比通常意义上的符号表要更为广泛.
    每一个运行时常量池都在 Java 虚拟机的方法区中分配,在加载类和接口到虚拟机后,就创建对应的运行时常量池.
    在创建类和接口的运行时常量池时,可能会发生如下异常情况:
      当创建类或接口时,如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值,那么 Java 虚拟机将会抛出 OOM.
    运行时常量池中的所有引用最初都是符号引用。这些符号是按照如下方式，从类或接口的二进制表示中得出的：
      -- 某个类或接口的符号引用来自于类或接口二进制表示中的 CONSTANT_Class_info 结构. 这种引用提供的类或接口名称,其格式与
        Class.getName 方法的返回值一样,也就是说:
        - 对于非数组的类或接口,此名称是类或接口的二进制名称.
        - 对于一个 n 维数组类,名称会以 n 个 ASCII 字符 "[" 开头,随后是数组元素类型的表示
            - 如果数组的元素类型是 Java 原生类型之一,那就以相应的字段描述符来表示.
            - 否则,如果数组元素类型是某种引用类型,那就以 ASCII 字符 "L" 加上二进制名称,并以 ASCII 字符 ";" 结尾的字符串表示.
      -- 类或接口的某个字段的符号引用来自于类或接口二进制表示中的 CONSTANT_Fieldref_info 结构. 这种引用包含了字段的名称和描述符,
        以及指向字段所属类或接口的符号引用.
      -- 类中某个方法的符号引用来自于类或接口二进制中的 CONSTANT_Methodref_info 结构. 这种引用包含了方法的名称和描述符,
         以及指向方法所属类的符号引用.
      -- 接口中某个方法的符号引用来自于类或接口二进制表示中的 CONSTANT_InterfaceMethodref_info 结构. 这种引用包含了接口方法的名称
         和描述符,以及指向方法所属接口的符号引用. 对于不同类型的方法句柄来说,由该引用所给出的另一个符号引用也不相同,那个
         符号引用可能会指向类或接口种的字段,也有可能指向类中的方法,还有可能指向接口中的方法.
      -- 方法句柄(method handle)的符号引用来自于类或接口二进制表示中的 CONSTANT_MethodHandle_info 结构. 这种引用给出了方法
         描述符.
      -- 方法类型(method type)的符号引用来自类或介科狗二进制表示中的 CONSTANT_Method_info 结构.
      -- 调用点限定符(call site specifier) 的符号引用来自于类或接口二进制表示中的 CONSTANT_InvokeDynamic_info 结构.
         这种引用包含了:
         - 方法句柄的符号应用,以用作 invokedynamic 指令的引导方法.
         - 一系列符号引用(指向类,方法类型和方法句柄),字符常量和运行时常量值,它们将作为 静态参数(static argument) 提供给引导方法.
         - 方法的名称与描述符.
      -- 另外,有些运行时值不是符号引用,而是来自常量池表中的某些项:
        - 字符串常量是指向 String 类实例的引用,它来自于类或接口二进制表示中的 CONSTANT_String_info 结构.
          CONSTANT_String_info 结构给出了由 Unicode 码点(code point) 序列所组成的字符串常量.
          注: 码点 是指组成字符集代码空间的数值表示,譬如 ASCII 有 0x0 至 0x7F 共 128 个码点, 扩展 ASCII 有 0x0 至 0xFF 共
           256 个码点, 而 Unicode 则有 0x0 至 0x10FFFF 共 1,114,112 个码点.
        Java 语言规定,相同的字符串常量(也就是包含同一份码点序列的常量)必须指向同一个 String 类实例. 此外,如果在任意字符串上
        调用 String.intern 方法,那么返回结果指向的那个类实例,必须和直接以常量形式出现的字符串实例完全相同. 因此, 下列表达式
        的值必定为 true: ("a" + "b" + "c").intern() == "abc";
        为了得到字符串常量,Java 虚拟机需要检查 CONSTANT_String_info 结构中的码点序列.
        - 如果某 String 实例所包含的 Unicode 码点序列与 CONSTANT_String_info 结构所给出的序列相同,而之前又层在该实例上调用过
          String.intern 方法,那么此次字符串常量获取的结果将是一个指向相同 String 实例的引用.
        - 否则,会创建一个新的 String 实例,其中包含由 CONSTANT_String_info 结构所给出的 Unicode 码点序列; 字符常量获取的结果
          是指向那个新 String 实例的引用. 最后,新 String 实例的 intern 方法被 Java 虚拟机自动调用.
      -- 其他运行时常量值来自于类或接口二进制表示 CONSTANT_Integer_info,CONSTANT_Float_info,CONSTANT_Long_info 或是
         CONSTANT_Double_info 结构.
      在类或接口的二进制表示中,常量池中剩下的结构还有 CONSTANT_NameAndType_info 和 CONSTANT_Utf8_info,它们被间接用来获得对
      类,接口,方法,字段,方法类型和方法句柄的符号引用,或在需要得到字符常量和调用点限定符时使用.
6. 本地方法栈
    Java 虚拟机实现可能会使用到传统的栈(通常称为 C stack)来支持 native 方法(指使用 Java 以外的语言编写的方法)的执行,
    这个栈就是本地方法栈(native method stack). 当 Java 虚拟机使用其他语言(如 C 语言)来实现指令集解释器时,也可以使用本地方法栈.
    如果 Java 虚拟机不支持 native 方法,或是本身不赖传统栈,那么可以不提供本地方法栈,如果支持本地方法栈,那这个栈一般会在
    线程创建的时候按线程分配.
    Java 虚拟机规范允许本地方法栈实现成固定大小或者根据计算来动态扩展和收缩. 如果采用固定大小的本地方法栈,那么每个线程的本地方法栈
    容量可以在创建栈的时候独立选定.
    Java 虚拟机实现应当提供给程序员或者最终用户调节本地方法栈初始容量的手段,对于长度可动态变化的本地方方法栈来说,则应当提供
    调节其最大,最小容量的手段.
    本地方法栈可能发生如下异常:
      1. 如果线程请求分配的栈容量超过本地方法栈允许的最大容量,Java 虚拟机将会抛出一个 StackOverflowError.
      2. 如果本地方法栈可以动态扩展,并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的
        本地方法栈,那么 Java 虚拟机将会抛出 OOM.
-------------
栈帧 frame
    用来存储数据和部分过程结果的数据类型,同时也用来处理动态链接(dynamic linking),方法返回值和异常分派(dispatch exception).
    栈帧随着方法调用而创建,随着方法结束而销毁--无论方法是正常完成还是异常完成(抛出在方法内未被捕获的异常)都算作方法结束.
    栈帧的存储空间由创建它的线程分配在 Java 虚拟机栈,每个栈帧都有自己的本地变量表(local variable),操作数栈(operand stack)
    和指向当前方法所属的类的运行时常量池的引用.
    栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息,例如,对程序调试提供支持的信息.
    本地变量表和操作数栈的容量在编译期确定,并通过相关方法的 code 属性保存及提供给栈帧使用. 因此,栈帧数据结构的大小仅仅取决于
    Java 虚拟机的实现.实现者可以在调用方法时给他们分配内存.
    在某条线程执行过程中的某个时间点上,只有目前正在执行的那个方法的栈帧是活动的.这个栈帧称为 当前栈帧(current frame),
    这个栈帧对应的方法称为 当前方法(current method),定义这个方法的类称作 当前类(current class). 对局部变量表和操作数栈的各种
    操作,通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作.
    如果当前方法调用了其他方法,或当前方法执行结束,那这个方法的栈帧就不再是当前栈帧了. 调用新的方法时,新的栈帧也会随之而创建,
    并且会随着程序控制权移交到新方法而称为新的当前栈帧. 方法返回之际,当前栈帧会传回此方法的执行结果给前一个栈帧,然后,虚拟机
    会丢弃当前栈帧,使得前一个栈帧重新成为当前栈帧.
    注意,栈帧是线程本地私有的数据,不可能在一个栈帧之中引用另外一个线程的栈帧.
  1. 局部变量表
    每个栈帧内部都包含一组称为局部变量表的变量列表. 栈帧中局部变量表的长度由编译期决定,并且存储于类或接口的二进制表示之中,
    即通过方法的 code 属性保存及提供给栈帧使用.
    一个局部变量可以保存一个类型为 boolean,byte,char,short,int,float,reference,returnAddress 的数据.
    两个局部变量可以保存一个类型为 long 或 double 的数据.
    局部变量使用索引来进行定位访问. 首个局部变量的索引值为 0. 局部变量的索引值是个整数,它大于等于 0,且小于局部变量表的长度.
    long 和 double 类型的数据占用两个连续的局部变量,这两种类型的数据值采用两个局部变量中较小的索引值来定位. 例如, 将一个
    double 类型的值存储在索引值为 n 的局部变量中,实际上的意思是索引值为 n 和 n+1 的两个局部变量都用来存储这个值. 然而,
    索引值为 n+1 的局部变量是无法直接读取的,但是可能会被写入. 不过,如果进行了这种操作,那将会导致局部变量 n 的内容失效.
  2. 操作数栈
    每个栈帧内部都包含一个称为 操作数栈的后进先出(Last-In-First-Out,LIFO)栈. 栈帧中操作数栈的最大深度由编译期决定,并且通过方法
    的 code 属性保存及提供给栈帧使用.
    在不产生误解的前提下,经常把 "当前栈帧的操作数栈" 直接简称为 "操作数栈".
    栈帧在刚刚创建时,操作数栈是空的. Java 虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中,
    也提供了一些指令用于从操作数栈取走数据,操作数据以及把操作结果重新入栈. 在调用方法时,操作数栈也用来准备调用方法的参数以及
    接收方法返回结果.
    例如, iadd 字节码指令的作用是将两个 int 类型的数置相加,它要求在执行之前操作数栈的栈顶已经存在两个由前面的其他指令所放入的
    int 类型数值. 在执行 iadd 指令时,两个 int 类型数值从操作数栈中出栈,相加求和,然后将求和结果重新入栈. 在操作数栈中,一项运算
    常由多个子运算(sub-computation)嵌套进行,一个子运算过程的结果可以被其他外围运算所使用.
    操作数栈的每个位置上可以保存一个 Java 虚拟机中定义的任意数据类型的值,包括 long 和 double 类型.
    在任意时刻,操作数栈都会有一个确定的栈深度,一个 long 或者 double 类型的数据会占用两个单位的栈深度,其他数据类型则会占用一个单位的栈深度.
  3. 动态链接
    每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用,以便对当前方法的代码实现 动态链接. 在 class 文件里面, 一个
    方法若要调用其他方法,或者方法问成员变量,则需要通过符号引用(symbolic reference)来表示,动态链接的作用就是将这些以符号引用
    所表示的方法转换为对实际方法的直接引用. 类加载的过程中要解析尚未被解析的符号引用,并且将对变量的访问转化为变量在运行时,
    位于存储结构中的正确偏移量.
    由于对其他类中的方法和变量进行了 晚期绑定(late binding), 所以即便那些类发生变化,也不会影响调用他们的方法.
-------------------------------
描述符：Descriptor
  一个描述字段或方法类型的字符串。
  描述符和签名都是用特定的语法符号来表示的。这些语法是一组规则，用来表达怎样以一串字符构建出语法正确的各种描述符。
  在本规范中，语法的终止符号（terminal symbol）用定宽的字体表示。非终止符号（non-terminal symbol）用斜体字表示，
  非终止符的定义由被定义的非终止名后跟随一个冒号来表示。冒号下方会有一个或多个可供选用的非终止符定义，每个非终止符的定义占一行。
  规则右边的 {x} 表示 x 出现 0 次或多次。
  如果某条规则的冒号右侧出现了 “one of” 字样，那就表明下面一行或下面几行所列出的每个终止符号，都是可供选用的定义（alternative definition）.
  1. 字段描述符 field descriptor
     用来表示类，实例或局部变量。
     FiledDescriptor:
        FieldType
     FiledType:
        BaseType
        ObjectType
        ArrayType
     BaseType: one of
        B C D F I J S Z
     ObjectType:
        LClassName;
     ArrayType:
        [ComponentType
     ComponentType:
        FieldType
     用来表示基本类型（BaseType）的各个字符，用来表示对象类型（ObjectType）的字符 “L” 和 “;”,
     以及用来表示数组类型(ArrayType)的 "[" 字符都是 ASCII 编码的字符.
     对象类型(ObjectType)中的 ClassName 表示一个类或接口二进制名称,它是以内部形式来编码的.
     ----------
     FieldType中的字符             类型               含义
        B                          byte              有符号的字节型数
        C                          char              基本多文种平面中的 Unicode 字符码点,UTF-16 编码
        D                          double            双精度浮点数
        F                          float             单精度浮点数
        I                          int               整型数
        J                          long              长整数
        LClassName;                reference         ClassName 类的实例
        S                          short             有符号短整型
        Z                          boolean           布尔值 true/false
        [                          reference         一个一维数组
  2. 方法描述符  method descriptor
     包含 0 个或多个参数描述符(parameter descriptor)以及 1 个返回值描述符(return descriptor).
     参数描述符表示该方法所接受的参数类型,如果该方法有返回值的话,那么返回值描述符则表示该方法的返回值类型.
     MethodDescriptor:
         ({ParameterDescriptor})ReturnDescriptor
     ParameterDescriptor:
         FieldType
     ReturnDescriptor:
         FieldType
         VoidDescriptor
     VoidDescriptor:
         V
     字符 V 表示该方法不返回任何值(void)
     eg: Object m(int i, double d, Thread t) {...}
     该方法描述符为: (IDLjava/lang/Thread;)Ljava/lang/Object;


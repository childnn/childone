物理层: 集线器
数据链路层: 交换机. MAC 地址 (MAC 地址表: 映射 MAC 地址与端口)
网络层: 路由器. IP 地址 (ARP 根据 IP 地址解析 MAC 地址)(路由表: 映射 IP 地址与端口)
    电脑和路由器中有 ARP 缓存表: 用来缓存 IP 和 MAC 地址映射关系
详述:
   1. 集线器(HUB): 物理层
     数据包模式(内外包裹关系): (源MAC/目的MAC(数据包))
     将电信号广播到所有出口, 不做任何处理. 无法识别 MAC/IP 地址.
     由 host 根据 目的 MAC 地址是否属于自己自行判断 接收/丢弃.
   2. 交换机: 数据链路层
     数据包模式: 数据链路层头部+数据包, (源MAC/目的MAC(数据包))  -- 此处的 源MAC/目的MAC 在传递过程中是不变的.
     目的: 集线器只有广播功能, 为了能发到指定的目的地, 定义 MAC 地址.
        即 交换机比集线器多了解析 MAC 地址功能.
     交换机维护一张 MAC 地址表, 记录每个 MAC 地址的设备, 对应交换机的哪个端口(MAC 地址-端口映射)
     起初, MAC 地址表为空, 由 MAC-A/port-n 发送到 MAC-B/port-m 的数据, 由于无法确定目的地,
     会执行广播, 发送到所有端口. 最终 MAC-B 收到数据包后, 会将端口信息响应给 交换机, 这样交换机中新增一条 MAC/port 映射.
     如此, 随着通信进展, 交换机中会记录所有 MAC/port 的映射.
   3. 路由器: 网络层
     数据包模式: 数据链路层头部+网络层头部+数据包, (源MAC/目的MAC(源IP/目的IP)(数据包))  -- 此处的 源MAC/目的MAC 会随着数据传递改变.
     目的: 交换机端口有限, 为了连接不同交换机, 定义 IP 地址.
     随着 host 越来越多, 单个交换机端口必然不够用. 可以将交换机与交换机连接.
     但是, 这样 交换机 A 为了可以与交换机 B 的每一台 host 通信, 必须记录自己与交换机 B 连接的端口和交换机 B 上所有 host 的 MAC 地址映射
     比如, 交换机 A 的 port-n 与 交换机 B 相连, 交换机 B 上连接的每一个 host 都需要注册到 交换机 A 的 MAC 地址表中.
        交换机 B 上 host 的 MAC 地址          交换机 A 上的端口(与交换机 B 相连的那个端口)
             b-1-2-3-4                              n
             b-1-2-3-5                             同上(都通过 n 端口转向 交换机 B, 再通过 交换机 B 的 MAC 地址表和目的 host 的 MAC 地址找到 host 在 B 上的端口)
             b-1-2-3-6                             同上
             b-1-2-3-7                             同上
     如此, 每个交换机的 MAC 地址表数据量过大, host 过多时将不现实.
     (思考: 上述问题产生的原因是, 交换机自己没有 MAC 地址, 数据包中只有源MAC 和目的MAC. 如果交换机自己有 MAC, 可以在当前交换机找不到目的 MAC 时, 再转发到下一个交换机
      此时, 这个 "交换机" 改名为 路由器.)
     路由器本身可以认为是独立的 host, 有自己的 MAC 地址(路由器的每个端口都有一个 独立的 MAC 地址), 这样在当前交换机的 MAC 地址表中没有目的MAC 地址时, 便转向路由器
     todo: 为什么不直接在 不变的 源 MAC/目的 MAC 之外再加一层 随着传递过程可变的 MAC 地址层???
     上述问题暂不明确, 这里先直接解释 IP 地址.
     MAC 地址为物理地址,硬件地址,长度 48位, 00-16-EA-AE-3C-40, 由网络设备制造商生产时烧录在网卡的 EPROM(一种闪存芯片, 通常可以通过程序擦写).
     其前 24 位(00-16-EA) 代表网络硬件制造商的编号, 后 24 位为该厂家自己分配, 一般表示系列号. 只要不更改自己的 MAC 地址, MAC 唯一, 静态.
     而 IP 地址(此处以 IPv4 为例)可变, 32 位, 点分十进制分四个 8位(192.168.0.1).
     如此, 每个 host 都有自己的 MAC 地址与 IP 地址.
     1. 数据包何时需要通过路由器转发?
      子网: 如果源ip 与目的 ip 处于一个子网, 直接将包通过交换机发出去. 如果源 ip 与目的 ip 不处于一个子网, 转交路由器.
       何为处于一个子网?
       192.168.0.* 表示同一个子网
       对于计算机, 需要协助 子网掩码 来判断. 将源ip 与目的 ip 分别同 子网掩码按位与, 相等则为一个子网, 否则不为一个子网.
       eg: 192.168.0.1 & 255.255.255.0 = 192.168.0.0
           192.168.0.2 & 255.255.255.0 = 192.168.0.0
           192.168.1.1 & 255.255.255.0 = 192.168.1.0
           由结果是否相等, 判断是否为同一子网.
       非同一个子网的数据包由路由器转发: 路由器会解包/组包, 更改 源MAC(自己的MAC)/目的MAC(下一跳的MAC)
     2. 如何知道路由器的 ip?
       默认网关.
       对于源host 来说, 只能发给某个 ip, 即需设置参数 默认网关(在当前路由器范围下找不到目的 ip 就发给默认网关).
       此时已经需要的几个重要参数: ip 地址, mac 地址, 子网掩码, 默认网关
     3. 路由器如何找到 目的 host?
       路由表(路由算法).
       路由器收到数据包中有 目的 ip. 路由表中有 目的地址/目的地址子网掩码/对应的路由器端口/下一跳地址
       目的地址             目的地址的子网掩码           端口      下一跳(下个路由器 ip, 通过 ARP 得到 MAC 地址)
       192.168.0.0          255.255.255.0            0           ---
       192.168.0.33         255.255.255.0            0           ---
       192.168.1.xx         255.255.255.255          1           ---
       目的地址和目的子网掩码可以简写: 192.168.0.0/24  (24 表示子网掩码前 24 位为子网的网段, 即前 24 位全为 1, 也即 255.255.255.0)
       即 192.168.0.* 子网下的数据包都转发到 当前路由器 0 端口.
     4. 如何由 ip 地址得到 MAC 地址?
        APR 协议与 ARP 缓存表.
        在发送中, 实际都是只知道 ip 地址, 通过 ARP(address resolution protocol) 协议, 解析 ip 地址得到 MAC 地址.
        ARP 缓存表中记录 IP/MAC 地址映射. 类似 MAC 地址表, ARP 缓存表起初为空, 目的 host 收到消息后, 会响应自己的 MAC 地址.

   在整个转发过程中, 数据链路层头部(源MAC/目的MAC)会变化, 即在每个路由器节点存在解包/组包, 更换 MAC 地址过程, 而网络层头部(源IP/目的IP)不会改变.
-----
 各个节点:
   host:
     1. 知道源 ip(自己的 ip)与目的 ip
     2. 通过 子网掩码 判断 目的 ip 是否在同一 子网
     3. 若为同一子网, 则通过 ARP 获取 MAC 地址发送消息
     4. 若不同子网, 则通过 ARP 获取默认网关 MAC 地址发给路由器
   交换机:
     1. 收到的数据包必须有 目的 MAC 地址
     2. 通过 MAC地址表确定转发端口
     3. 查不到就广播
   路由器:
     1. 收到的数据包必须有目的 ip 地址
     2. 通过 路由表查映射关系
     3. 查到就按映射关系从指定端口发送(路由器自己也存在默认网关, 最终可达)
     4. 否则返回不可达
 todo: 网络层(IP 协议) 本身没有传输包的功能, 实际传输委托给数据链路层(交换机)实现.









应用层:
HTTP: HyperText Transfer Protocol
    生成针对目标 Web 服务器的 HTTP 请求报文.
DNS: Domain Name System
    提供 域名 到 IP 地址 之间的解析服务(用户输入的网址[www.xx.com]即为 域名,通过 DNS 服务查询到对应的 IP 地址[20x.189.105.112]).
FTP: File Transfer Protocol

HTTP -> TCP -> IP ->
----------------------------------------------------

传输层:
TCP: Transmission Control Protocol
    可靠的 字节流服务(Byte Stream Service)
    为了方便通信,将 HTTP 请求报文分割成报文段,把每个报文段加上 TCP首部 后进行下一步传输(可靠的传输到网络层).
UDP: User Data Protocol

----------------------------------------------------

网络层:
    处理网络上流动的数据包. 数据包是网络传输的最小数据单位. 该层规定了通过怎样的路径(传输路线)
    到达对方计算机,并把数据包传送给对方. 与对方计算机之间通过多台计算机或网络进行传输时,网络层所起
    的作用就是在众多的选项内选择一条传输路线.
IP: Internet Protocol
    (搜索对方的地址,一边中转一边传送)
     把各种数据包传送给对方. 其中两个重要的条件是 IP 地址和 MAC 地址(Media Access Control Address).
    IP 地址指明了节点被分配到的地址, MAC 地址是指网卡所属的固定地址. IP 地址可以和 MAC 地址进行配对.
    IP 地址可变换,但 MAC 地址基本上不会更改. 基本上各大网卡制作厂商都被预制分配了 MAC 地址区间段.
    IP 间的通信依赖 MAC 地址. 在网络上,通信的双方在同一局域网(LAN,Local Area Network)内的情况是很少的,
    通常是经过多台计算机和网络设备中转才能连接到对方. 而在进行中转时,会利用下一站中转设备的 MAC 地址来搜索
    下一站中转目标. 这时会采用 ARP 协议(Address Resolution Protocol). ARP 是一种用以解析地址的协议,
    根据通信方的 IP 地址就可以反查出对应的 MAC 地址.
    在到达通信目标前的中转过程中,那些计算机和路由器等网络设备只能获悉很粗略的传输路线. 这种机制称为 路由选择(routing).

----------------------------------------------------
数据链路层:
    用来处理连接网络的硬件部分. 包括控制操作系统,硬件的设备驱动,NIC(Network Interface Card, 网络适配器,即网卡),
    及光纤等物理可见部分(还包括连接器等一切传输媒介).
    硬件上的范畴均在链路层的作用范围之内.
LLDP: Link Layer Discovery Protocol 链路层发现协议
    随着网络技术的发展,接入网络的设备种类越来越多,配置越来越复杂,来自不同设备厂商的设备也往往会增加自己特有的功能,这就导致在
    一个网络中往往会有很多具有不同特性的、来自不同厂商的设备,为了方便这样的网络进行管理,就需要使得不同厂商的设备能够在网络中
    相互发现并交互各自的系统及配置信息.

互联网通信传输流:
  1. 作为发送端的客户端在 应用层(HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求.
  2. 在 传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求报文)进行分割,并在各个报文上打上 标记序列号及端口号 后转发给 网络层.
  3. 在网络层(IP 协议),增加作为 通信目的地 的 MAC 地址后转发给 链路层. 这样一来,发往网络的通信请求就准备齐全了.
  4. 接收端的服务器在 链路层 接收到数据,按序往上层发送(相对于客户端的发送,服务端的接收是逆向的拆包过程),一直到应用层.
     当传输到应用层,才能算真正接收到由客户端发送过来的 HTTP 请求.
  发送端在层与层之间传输数据时,每经过一层时必定会被打上一个该层所属的首部信息. 反之,接收端在 层与层传输数据时,每经过一层时会把对应的
  首部消去. 这种把数据信息包装起来的做法称为 封装(encapsulate).



IEEE 802.3
FDDI
ICMP
SNMP
PPPoE

WWW: World Wide Web
WAN: Wide Area Network
LAN: Local Area Network
WLAN: Wireless Local Area Network

常用版本号：
    Alpha：软件或系统的内部测试版本，会有很多Bug，仅内部人员使用
    Beta：软件或系统的测试版本，这一版本通常是在Alpha版本后，会有很多新功能，同时也有不少Bug
    Gamma：软件或系统接近于成熟的版本，只需要做一些小的改进就能发行
微软常用的版本号：
    RC（Release Candidate）：候选版本，这一版本不会增加新功能，多要进行Debug
    GA（General Available）：正式发布版本，这个版本就是正式的版本
    RTM（Release to Manufacture）：给工厂大量生产的压片版本，与正式版内容一样
    OEM（Original Entrusted Manufacture）：给计算机厂商的出场销售版本，不零售只预装
    RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的
    EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别
    RTL（Retail）：零售版是真正的正式版，正式上架零售版
苹果常用的版本号：
    GM（Gold Master）：正式版前最后一个测试版，其实也就是正式版
谷歌Chrome浏览器常用的版本号：
    Chromium：开源版本，迭代速度极快，数小时就会有新版本，有很多新功能，等待验证后会移植到Chrome
    Canary：迭代速度相对于Chromium版稍慢一些，功能非常新但未经过验证，同时崩溃的概率非常高
    Dev：基于Chromium开发，每周出新功能，并且这些功能还有一定的筛选，另外还修复了一些Bug和不稳定因素
    Beta：基于Dev版，Chrome会基于这一版本进行改进，一般按月更新，功能更加完善
    Stable：稳定版本，也就是Chrome的正式版本，这一版本基于Beta版，已知Bug都被修复，一般情况下，更新比较慢
Ubuntu系统常用的版本号：
    LTS（Long Term Support）：长期演进版，Ubuntu会对这一版本的支持时间更长。目前Java也在运用这种方式
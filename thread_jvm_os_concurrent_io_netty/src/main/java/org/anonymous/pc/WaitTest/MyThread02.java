package org.anonymous.pc.WaitTest;

/**
 * 2019年2月19日16:04:36
 * 线程状态。 线程可以处于以下状态之一：
 * NEW：新建线程 ---> Thread t = new Thread();
 * 尚未启动的线程处于此状态。
 * RUNNABLE：就绪---> t.start() 方法调用，进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，
 * 随时等待CPU调度执行（或者说拥有了抢夺cpu资源的权限），并不是说执行了t.start()此线程立即就会执行
 * 在Java虚拟机中执行的线程处于此状态。
 * Running：正在jvm中运行。当cpu开始调度处于就绪状态的线程时，此线程才得以真正执行，即进入运行状态。
 * 【注】：【就绪状态是进入到运行状态的唯一入口】，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中
 * BLOCKED：拥有cpu执行资格，等待cpu空闲
 * 被阻塞等待监视器锁定的线程处于此状态。
 * 处于运行状态中的线程由于某种原因，【暂时放弃】对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。
 * 根据阻塞产生的原因不同，阻塞状态又可以分为三种：
 * 1.【等待阻塞】 -- 运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态（无限等待）；
 * 2.【同步阻塞】 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
 * 3.【其他阻塞】 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
 * WAITING：（无限等待，放弃cpu执行资格，等待 notify()）通过 Object 的 wait()方法启动waiting状态， Object.notify() 唤醒
 * 无限等待另一个线程执行特定动作（notify）的线程处于此状态。
 * TIMED_WAITING （计时等待,休眠 wait(long) 类似 sleep(long)，但是wait() 过程中会放开锁对象的拥有权）到时间自动 就绪
 * 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
 * TERMINATED （线程运行完毕或出现异常）
 * 已退出的线程处于此状态。
 * 一个线程在给定时间点只能处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。
 * （在给定时间点上，一个线程只能处于一种状态。这些状态是虚拟机状态，它们并没有反映所有操作系统线程状态）
 * <p>
 * new， runnable， running， terminated
 * 就绪状态转换为运行状态：当此线程得到处理器资源；
 * 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。
 * 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。
 * 此处需要特别注意的是：
 * 当调用线程的yield()方法时，线程从运行状态转换为就绪状态，
 * 但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。
 * <p>
 * 从以下版本开始： 1.5
 */
public class MyThread02 {
    public static void main(String[] args) {
        String[] arr = {"new --> runnable -- > running"};
    }
}

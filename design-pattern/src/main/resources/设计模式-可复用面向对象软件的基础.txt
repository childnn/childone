模式四要素:
1. 模式名称: pattern name.
2. 问题: problem.
  描述在何时使用模式; 解释设计问题和问题存在的前因后果, 它可能描述了特定的设计问题, 如怎样用对象表示算法等.
  也可能描述导致不灵活设计的类或对象结构. 问题有时会包括使用模式必须满足的一系列先决条件.
3. 解决方案: solution.
  描述设计的组成成分, 它们之间的相互关系及各自的职责和协作方式. 因为模式就像一个模板, 可应用于多种不同场合,
  所以解决方案并不描述一个特定而具体的设计或实现, 而是提供设计问题的抽象描述和怎样用一个具体一般意义的元素
  组合(类或对象组合)来解决这个问题.
4. 效果: consequences.
  描述了模式应用的效果及使用模式应权衡的问题. 尽管我们描述设计决策时, 并不总是提到模式效果, 但它们对于评价设计选择
  和理解使用模式的代价及好处具有重要意义. 软件效果大多关注对时间和空间的衡量, 它们也表述了语言和实现问题. 因为
  复用是面向对象设计的要素之一, 所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响， 显式地列出这些效果对理解
  和评价这些模式很有帮助.

Smalltalk MVC 中的设计模式.
-- 在 Smalltalk-80 中, 类的模型/视图/控制器(Model/View/Controller) 三元组(MVC)被用来构建用户界面.
   透过 MVC 来看设计模式将帮助我们理解 "模式" 这一术语的含义.
   MVC 包括三类对象. 模型 Model 是应用对象, 视图 View 是它在屏幕上的表示, 控制器 Controller 定义用户界面对
   用户输入的响应方式. 不使用 MVC, 用户界面设计往往将这些对象混在一起, 而 MVC 则将它们分离以提高灵活性和复用性.
   MVC 通过建立一个 "订购/通知" 协议来分离视图和模型. 视图必须保证它的显示正确地反映了模型地状态.
   一旦模型地数据发生变化, 模型将通知有关地视图, 每个视图相应地得到刷新自己的机会. 这种方法可以让你为一个模型提供不同的
   多个视图表现形式, 也能够为一个模型创新的视图而无需重写模型.

描述设计模式.
-- 模式名和分类.
-- 意图.
   设计模式是做什么的? 它的基本原理和意图是什么? 它解决的是什么样的特定设计问题?
-- 别名.
   模式的其他名称.
-- 动机.
   用以说明一个设计问题以及如何用模式中的类、对象来解决该问题的特定情景.
   该情景会帮助你理解随后对模式更抽象的描述.
-- 适用性.
   什么情况下可以使用该设计模式? 该模式可用来改进哪些不良设计? 你怎样识别这些情况?
-- 结构.
   采用基于 对象建模技术(OMT: Object Modeling Technique) 的表示方法对模式中的类进行图形描述.
   使用交互图来说明对象之间的请求序列和协作关系.
-- 参与者.
   指设计模式中的类和/或对象以及它们各自的职责.
-- 协作.
   模式的参与者怎样协作以实现它们的职责.
-- 效果.
   模式怎样支持它的目标? 使用模式的效果和所需做的权衡取舍?
   系统结构的哪些方面可以独立改变?
-- 实现.
   实现模式时需要知道的一些提示、技术要点及应避免的缺陷, 以及是否存在某些
   特定于实现语言的问题.
-- 代码示例.
   用来说明怎样用 C++ 或 Smalltalk 实现该模式的代码片段.
-- 已知应用.
   实际系统中发现的模式的例子. 每个模式至少包括了两个不同领域的实例.
-- 相关模式.
   与这个模式紧密相关的模式有哪些? 其间重要的不同之处是什么?
   这个模式应与哪些其他模式一起使用?

Abstract Factory: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类.
Adapter: 将一个类的接口转换成客户希望的另外一个接口.
         Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.
Bridge: 将抽象部分与它的实现部分分离, 使它们都可以独立地变化.
Builder: 将一个复杂对象地构建与它地表示分离, 使得同样地构建过程可以创建不同地表示.
Chain of Responsibility: 为解除请求地发送者和接收者之间耦合, 而使多个对象都有机会处理
        这个请求. 将这些对象连成一条链, 并沿着这条链传递该请求, 直到有一个对象处理它.
Command: 将一个请求封装为一个对象, 从而使你可用不同的请求对客户进行参数化; 对请求排队或
        记录请求日志, 以及支持可取消的操作.
Composite: 将对象组合成树形结构以表示 "部分-整体" 的层次结构. Composite 使得客户对单个对象
        和符合对象的使用具有一致性.
Decorator: 动态地给一个对象添加一些额外的职责. 就扩展功能而言, Decorator 模式比生成子类方式更为灵活.
Facade: 为子系统中的一组接口提供一个一致的界面, Facade 模式定义了一个高层接口, 这个接口使得这一子系统
        更加容易使用.
Factory Method: 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化.
        Factory Method 使一个类的实例化延迟到其子类.
Flyweight: 运用共享技术有效地支持大量细粒度地对象.
Interpreter: 给定一个语言, 定义它的文法地一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中地句子.
Iterator: 提供一种方法顺序访问一个聚合对象中地各个元素, 而又不需暴露该对象地内部表示.
Mediator: 用一个中介对象来封装一系列的对象交互. 中介者使各对象不需要显示地相互引用, 从而使其耦合松散,
          而且可以独立地改变它们之间地交互.
Memento: 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态.
         这样以后就可将该对象恢复到保存的状态.
Observer: 定义对象间地一种一对多的依赖关系, 以便当一个对象的状态发生变化时, 所有依赖于它的对象都得到通知并自动刷新.
Prototype: 用原型实例指定创建对象的种类, 并且通过拷贝这个原型来创建新的对象.
Proxy: 为其他对象提供一个代理以控制对这个对象的访问.
Singleton: 保证一个类仅有一个实例, 并提供一个访问它的全局访问点.
State: 允许一个对象在其内部状态改变时改变它的行为. 对象看起来似乎修改了它所属的类.
Strategy: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可相互替换. 本模式使得算法的变化可独立于使用它的客户.
Template Method: 定义一个操作中的算法的骨架, 而将一些步骤延迟到子类中. Template Method 使得子类可以不改变一个算法的
        结构即可重定义该算法的某些特定步骤.
Visitor: 表示一个作用于某对象结构中的各元素的操作. 它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作.

 ------------------------------------------------------------------------------
                        目的
 -------------------------------------------------------------------------------
            创建型 Creational    结构型 Structural    行为型 Behavioral
 -------------------------------------------------------------------------------
范围  类     Factory Method        Adapter(类)      Interpreter, Template Method
 -------------------------------------------------------------------------------
     对象    Abstract Factory      Adapter(对象)    Chain of Responsibility
             Builder               Bridge          Command
             Prototype             Composite       Iterator
             Singleton             Decorator       Mediator
                                   Facade          Memento
                                   Flyweight       Observer
                                   Proxy           State
                                                   Strategy
                                                   Visitor
 -------------------------------------------------------------------------------
 -------------------------------------------------------------------------------
分类准则:
1. 目的准则: 模式是用来完成什么工作的.
   创建型(Creational), 结构型(Structural), 行为型(Behavioral).
   创建型模式与对象的创建有关,
   结构型模式处理类或对象的组合,
   行为型模式对类或对象怎样交互和怎样分配职责进行描述.
2. 范围准则: 指定模式主要是用于 类 还是用于 对象.
    类模式处理类和子类之间的关系, 这些关系通过继承建立, 是静态的, 在编译时刻便确定下来了.
    对象模式处理对象间的关系, 这些关系在运行时刻是可以变化的， 更具动态性.
    从某种意义上来说, 几乎所有模式都使用 继承机制, 所以 "类模式" 只指那些几种处理类间关系的模式,
    而大部分模式都属于对象模式的范畴.
    2.1. 创建型类模式 将对象的部分创建工作延迟到子类, 而创建型对象模式 则将它延迟到另一个对象中.
    2.2. 结构型类模式 使用继承机制来组合类, 而结构型对象模式 则描述了对象的组装方式.
    2.3. 行为型类模式 使用继承描述算法和控制流, 而行为型对象模式 则描述一组对象怎样协作完成单个对象所无法完成的任务.
    注: 有些模式经常会被绑在一起使用, 例如, Composite 常和 Iterator 或 Visitor 一起使用; 有些模式是可替代的,
       例如, Prototype 常用来替代 Abstract Factory; 有些模式尽管使用意图不同, 但产生的设计结果是很相似的, 例如,
       Composite 和 Decorator 的结构图是相似的.

面向对象设计最困难的部分是 将 系统 分解成 对象 集合. 因为要考虑许多因素: 封装, 粒度, 依赖关系, 灵活性, 性能, 演化, 复用等等,
   它们都影响着系统的分解, 并且这些因素通常还是相互冲突的.

对象声明的每一个操作(operation 方法: function/method)指定 操作名、作为参数的对象和返回值， 这就是所谓的 操作的型构(signature)(方法的签名).
对象操作所定义的所有操作型构的集合被称为该对象的 接口(interface). 对象接口描述了该对象所能接受的全部请求的集合, 任何匹配对象接口
中 型构 的请求都可以发送给该对象.
类型(type) 是用来标识特定接口的一个名字. 如果一个对象接收 "Window" 接口所定义的所有操作请求, 那么我们就说该对象具有 "Window" 类型.
一个对象可以有许多类型, 并且不同的对象可以共享同一个类型.
对象接口的某部分可以用某个类型来刻画, 而其他部分则可用其他类型刻画. 两个类型相同的对象只需要共享它们的部分接口.
接口可以包含其他接口作为子集. 当一个类型的接口包含另一个类型的接口时, 我们就说它是另一个类型的 子类型(subtype),
另一个类型称之为它的 超类型(supertype).

动态绑定: dynamic binding.
   发送的请求直到运行时刻才受你的具体的实现的约束.
   当对象发送请求时, 所引起的具体操作既与请求本身有关又与接受对象有关. 支持相同请求的不同对象可能对请求激发的操作
   有不同的实现. 发送给对象的请求和它的相应操作在运行时刻的连接就称之为 动态绑定.
   进一步讲, 动态绑定允许你在运行时刻彼此替换有相同接口的对象.--这种可替换性就成为 多态(polymorphism).
   多态 简化了客户的定义, 使得对象间彼此独立, 并可以在运行时刻动态改变它们相互的关系.

继承与组合:
  类继承: 允许你根据其他类的实现来定义一个类的实现. 这种通过生成子类的复用通常被称为 白箱复用(white-box reuse).
    术语 "白箱" 是相对可视性而言: 在继承方式中, 父类的内部细节对子类可见.
  对象组合: object composition. 新的更复杂的功能可以通过组装或组合对象来获得. 对象组合要求被组合的对象具有
    良好定义的接口. 这种复用风格被称为 黑箱复用(black-box reuse), 因为对象的内部细节是不可见的.







On Java8
--------
模式的基本概念也可以看作是程序设计的基本概念: 添加抽象层
将易变的事物与不变的事物分开.
开发一个优雅且易维护设计中最困难的部分是发现 变化的载体(也就是最易改变的地方)
设计模式的目标是隔离代码中的更改.

继承 可以被认为是一种设计模式(由编译器实现), 它允许你表达所有具有相同接口的对象
 (即保持相同的行为)中的行为差异(这就是变化的部分).
组合 也可以被认为是一种设计模式, 它允许你动态或静态的更改实现类的对象, 从而改变类的工作方式.
迭代器: Java 1.0/1.1 名为 java.util.Enumeration, Java 2 使用 java.util.Iterator
  当你逐个选择元素时并逐步处理, 这会隐藏集合的特定实现. 迭代器允许你编写通用代码,
  改代码对序列中的所有元素执行操作, 而不考虑序列的构建方式.
---
即使模式是非常有用的, 但有些人断言: 设计模式代表语言的失败.
这是一个非常重要的见解, 因为一个模式在 C++ 有意义, 可能在 Java 或者其他语言中就没有意义.
处于这个原因, 所以一个模式可能出现在设计模式书上, 不意味着应用于你的编程语言是有用的.
---
设计模式分类:
   1. 创建型: 如何构建对象. 这通常设计隔离对象创建的细节, 这样你的代码就不依赖于具体的对象的类型.,
            因此在添加新类型的对象时不会更改.
   2. 结构型: 设计对象以满足特定的项目约束. 它们处理对象与其他对象连接的方式, 以确保系统中的更改
            不需要更改这些连接.
   3. 行为型: 处理程序中特定类型的操作的对象. 这些封装要执行的过程, 例如 解释语言、实现请求、遍历序列
            或实现算法.
---
面向实现:
    代理模式和桥接模式都提供了在代码中使用的代理类, 完成工作的真正类隐藏在这个代理类的后面.
    当在代理中调用一个方法时, 它反过来调用实现类中的方法. 这两种模式非常相似, 所以代理模式只是桥接模式
    的一种特殊情况. 人们倾向于将两者合并, 成为代理模式. 其基本思想很简单: 从基类派生代理, 同时派生一个或
    多个提供实现的类, 创建代理对象时, 给它一个可以调用实际工作类的方法的实现.
    在结构上, 代理模式和桥接模式的区别很简单: 代理模式只有一个实现, 而桥接模式有多个实现.
    在设计模式中被认为是不同的: 代理模式用于控制实现的访问, 而桥接模式允许动态更改实现.
状态模式:
    状态模式 向代理对象添加了更多的实现, 以及在代理对象的生命周期内从一个实现切换到另一种实现的方法.







The Timeless Way of Building. -- 建筑的永恒之道.
A Pattern Language. -- 建筑设计语言.

OO 设计原则:
 1. 封装变化: 找出程序中会变化的方面, 然后将其和固定不变的方面相分离.
 2. 多用组合, 少用继承.
 3. 针对接口编程, 不针对实现编程.
 4. 为了交互对象之间的松耦合设计而努力.
 5. 类应该对扩展开放, 对修改关闭. -- 针对最后可能改变的地方, 应用 开闭原则.
    在选择需要被扩展的代码部分时要小心, 每个地方采用 开闭原则, 是一种浪费, 也没必要,
    还会导致代码变的复杂且难以理解.
 6. 依赖倒置原则: Dependency Inversion Principle.
    要依赖抽象, 不要依赖具体类.
    不能让高层组件(子类)依赖低层组件(父类); 而且, 不管高层或低层组件, "两者" 都应该依赖于抽象.
    6.1. 变量不可以持有具体类的引用: 如果使用 new, 就会持有具体类的引用. 你可以改变工厂来
       避免这样的作法.
    6.2. 不要让类派生自具体类: 如果派生自具体类, 你就会依赖具体类. 请派生自一个抽象(接口或抽象类).
    6.3. 不要覆盖基类中已实现的方法: 如果覆盖基类已实现的方法, 那么你的基类就不是一个真正适合被继承的抽象.
       基类中已实现的方法, 应该由所有的子类共享.
 7. 最少知识原则: 只和密友交谈.
     就任何对象而言, 在该对象的方法内, 我们只应该调用属于一下范围的方法:
     7.1. 改对象本身;
     7.2. 被当作方法的参数传递进来的对象;
     7.3. 此方法所创建或实例化的任何对象;
     7.4. 对象的任何组件.
     注: 如果某对象时调用其他方法的返回结果, 不要调用该对象的方法.
 8. 好莱坞原则: don't call us, we will call you.
    别调用(打电话给) 我们, 我们会调用(打电话给) 你.
    低层组件可以参与计算, 但是高层组件控制何时以及如何让低层组件参与.
    低层组件(子类)绝对不可以直接调用高层组件(模板方法所在的类,父类).
    注: 事实上, 低层组件在结束时, 常常会调用从超类中继承来的方法. 我们所要
      做的是, 避免让高层和低层组件之间有明显的循环依赖.
 9. 单一责任原则: 一个类应该只有一个引起变化的原因.
    内聚 cohesion, 用来度量一个类或模块紧密地达到单一目的或责任.
    当一个模块或一个类被设计成只支持一组相关的功能时, 我们说它具有高内聚;
    反之, 当被设计成支持一组不相关的功能时, 我们说它具有低内聚.



模式: 某种情境(context)下, 针对某问题的某种解决方案.
  -- 情境: 应用某个模式的情况下. 这应该是会不断出现的情况.
  -- 问题: 你想在某情境下达到的目标, 但也可以是某情境下的约束.
  -- 解决方案: 你所追求的, 一个通用的设计, 用来解决约束、达到目标.


原型
单例: singleton. 确保一个类只有一个实例, 并提供一个全局访问点.
     想要取得单件实例, 通过单例类是唯一的途径.

适配器: adapter. 将一个类的的接口, 转换成客户期望的另一个接口. 适配器让
      原本不兼容的类可以合作无间.

策略: strategy. 定义算法族, 分别封装起来(多个接口及其各自的实现类), 让他们之间可以互相转换, 此模式让算法的变化独立于使用算法的客户.
    eg: 把接口的引用定义在类中, 调用接口的方法, 在运行时 setter 接口的实现类, 从而实现具体功能.
状态: 允许对象在内部状态改变时改变它的行为, 对象看起来好像修改了它的类.
    策略模式 和 状态模式是双胞胎, 在出生时才分开.
    策略模式是围绕可以互换的算法来创建成功业务的. 然而, 状态走的是更崇高的路, 它通过改变对象内部的
    状态来帮助对象控制自己的行为.

模板方法: template method.
     在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在
     不改变算法结构的情况下, 重新定义算法中的某些步骤.
     eg:
        1. java.util.Arrays.sort(java.lang.Object[]) 中调用的 java.lang.Comparable.compareTo 方法,
        2. java.io.InputStream.read() 方法由子类实现, 而这个方法又会被 java.io.InputStream.read(byte[], int, int) 模板方法使用.
   注: 关于 策略模式 与 模板方法模式.
     1. 策略模式通过对象组合的方式, 让客户可以选择算法实现.
     2. 模板方法模式定义算法的步骤/大纲, 由子类定义其中某些步骤的内容.
     另: 工厂方法是模板方法的一种特殊版本.


门面: 外观模式, facade. 提供一个统一的接口, 用来访问子系统中的一群接口.
     外观定义了一个高层接口, 让子系统更容易使用.

装饰者: 运行时(动态)扩展, 而非编译时(静态)继承. -- 少用继承, 多用组合.
     动态地将责任附加到对象上. 若要扩展功能, 装饰者提供了比继承更有弹性地替代方案.
     java.io.*
     利用装饰者模式, 常常造成设计中有大量的小类, 数量实在太多, 可能会造成使用此 API 程序员的困扰.

中介


迭代器: Iterator Pattern.
    提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示.
组合: Composite Pattern.
    允许你将对象组合成树形结构来表现 "整体/部分" 层次结构.
    组合能让客户以 一致的方式 处理个别对象以及对象组合.
    换句话说, 在大多数情况下, 我们可以忽略对象组合和个别对象之间的差别.

备忘录
责任链
观察者: observer. 定义对象之间的一对多依赖, 这样一来, 当一个对象改变状态时, 它的所有依赖着都
      会收到通知并自动更新.
      java.util.Observer
      java.util.Observable
      java.awt.event.ActionListener
      1. 主题("可观察者")用一个共同的接口来更新 观察者.
      2. "观察者" 和 "可观察者" 之间用松耦合方式结合 (loose-coupling), "可观察者" 不知道观察者的细节,
         只知道观察者实现了观察者接口.
      3. 使用此模式时, 你可从被观察者处 push/pull 数据 -- 一般而言, push 的方式被认为是正确的.
      4. 有多个观察者时, 不可以依赖特定的通知次序.

代理: proxy.
    为另一个对象提供一个替身或占位符以控制这个对象的访问.
    -- 远程代理: remote proxy. 另一个 JVM 上对象的本地代表.
       调用代理的方法, 会被代理利用网络转发到远程执行, 并且结果会通过
       网络返回给代理, 再由代理将结果转给客户.
    -- 虚拟代理: virtual proxy.
       作为创建开销大的对象的代表. 虚拟代理经常直到我们真正需要一个对象的时候才创建它.
       当对象在创建和创建中时, 由虚拟代理来扮演对象的替身. 对象创建后, 代理就会将请求直接
       委托给对象.
    -- 动态代理: dynamic proxy.
       java.lang.reflect 包. 运行时动态创建一个代理类, 实现一个或多个接口, 并将方法的调用转发到你所指定的类.
       注: 动态代理之所以被称为动态, 是因为运行时才将它的类创建出来. 代码开始执行时, 还没有 proxy 类, 它是根据
       需要从你传入的接口集创建的.


工厂模式:
    简单工厂模式: simple factory.
    工厂方法模式: factory method.
        定义一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.
    抽象工厂模式: abstract factory.
        提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类.
        抽象工厂允许客户使用抽象的接口来创建一组相关的产品, 而不需要知道(或关心) 实际产出
        的具体产品是什么.
    工厂方法使用继承, 把对象的创建委托给子类, 子类实现工厂方法来创建对象.
    抽象工厂使用对象组合, 对象的创建被实现在工厂接口所暴露出来的方法中.

桥接: Bridge
   不只改变你的实现, 也改变你的抽象.


抽象工厂
建造者

命令模式: 封装调用. 将 "请求"(命令) 封装成对象, 以便使用不同的请求、队列或者日志来参数化其他对象.
      命令模式也支持可撤销的操作.

访问者
解释器

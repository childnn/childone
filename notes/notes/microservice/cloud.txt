单体架构 -> 分布式架构 -> SOA(Service Oriented Architecture) -> 微服务架构(MicroServices)

HSF: High Speed Service Framework

中间件: 中间件, 操作系统, 数据库并列为传统基础软件的三驾马车
   常见中间件:
      服务治理中间件: Dubbo 等 RPC 框架
      配置中心
      全链路监控
      分布式事务
      分布式定时任务
      消息中间件
      API 网关
      分布式缓存
      数据库中间件


高可用, 高并发, 高性能

MicroServices 技术比较
                Spring Cloud                Dubbo
功能             微服务完整方案              服务治理框架
通信方式          REST/Http                  RPC 协议         -- 重要区别
服务发现/注册      Eureka(AP)                ZK(zookeeper)
负载均衡           Ribbon                    客户端负载
容错机制           6 种容错策略                同
熔断机制           Hystrix
配置中心           Spring Cloud Config       Nacos
网关              Zuul, GateWay              无
服务监控          Hystrix + Turbine           Dubbo + Monitor
链路监控           Sleuth + Zipkin            无
多语言            Rest 支持多语言             java

Spring Cloud 目前支持的注册中心: Eureka, Zookeeper, Consul, 且预留了扩展接口 (开闭原则)

----------------------------------------------------------------------------------------------------------
 重点 beginning
----------------------------------------------------------------------------------------------------------

核心组件(重点!!!)
Netflix Eureka: 服务发现 (注册中心) 服务注册与发现
    Eureka Server: 服务端, 服务注册中心, 支持集群部署
    Eureka Client: 客户端, java 客户端, 用来处理服务注册于发现
    启动应用时, Eureka 客户端向服务端注册自己的服务信息, 同时将服务端的服务信息缓存到本地.
        客户端回合服务端周期性的进行心跳交互, 以更新服务租约和服务信息.
Netflix Ribbon: 基于 HTTP/TCP 客户端的负载均衡器
    Ribbon负载均衡策略：(了解)
        RoundRobinRule 轮询
        RandomRule 随机
        Retry 所有服务都正常的时候等价于轮询，当某些服务挂掉的时候会自动进行重试以获取可用的服务
        AvailabilityFilteringRule
        WeightedResponseTimeRule
        BestAvailableRule
        ZoneAvoidanceRule
Netflix Hystrix: 断路器 (短路保护), 保护系统, 控制故障范围
    为了保证高可用, 单个服务通常会集群部署. 由于网络原因或者自身的原因, 服务不能保证 100% 可用,
    如果单个服务出现问题, 调用这个服务就会出现线程阻塞, 此时若有大量的请求涌入, Servlet 容器的线程
    资源会被消耗完毕, 导致服务瘫痪. 服务与服务之间的依赖性, 故障会传播, 会对整个微服务系统造成灾难性
    的严重后果, 这就是服务故障的 "雪崩" 效应.
Netflix Zuul: 服务网关(gateway), 路由, 负载均衡等
    类似 nginx, 反向代理的功能, 不过 netflix 自己增加了一些配合其他组件的特性
    在微服务架构中, 后端服务往往不直接开放给调用端, 而是通过一个 API 网关根据请求的 url, 路由到相应的服务.
    当添加 API 网关后, 在第三方调用端和服务提供方之间就创建了一面墙, 这面墙直接与调用方通信进行权限控制,
    后将请求均衡分发给后台服务端.

    为什么要使用微服务网关:
    在微服务架构中, 用户完成一个业务操作,可能涉及到访问一个项目中的多个微服务.
    如果让客户端直接与各个微服务通信,会有以下问题:
      客户端多次请求不同的微服务,增加了客户端的复杂性.
      存在跨域请求,在一定场景下处理相对复杂.
      认证复杂,每个服务都需要独立认证.
      难以重构,随着项目的迭代,可能需要重新划分微服务. 例如, 可能将多个服务合并成一个或者将一个服务拆分多个.
         如果客户端与微服务通信, 那么重构将会很难实施.
      某些微服务可能使用了 防火墙/浏览器不友好的协议, 直接访问会有一定的困难.
    以上问题,可借助微服务网关解决. 微服务网关是介于客户端和服务器端之间的中间层,
      所有的外部请求都会先经过微服务网关.

Spring Cloud Config: 分布式配置中心
    提供服务端和客户端. 服务器存储后端的默认实现使用 git, 因此它轻松支持标签版本的配置环境, 以及
    可以访问用于管理内容的各种工具.
    这是静态配置, 需要配合 Spring Cloud Bus 实现动态的配置更新.
Feign Client: 微服务远程调用采用的客户端负载均衡技术 // 整合 hystrix 和 ribbon

-------------------------------------------------------------------------------------------------------------------
重点 ending
-------------------------------------------------------------------------------------------------------------------

微服务, 微服务架构
   微服务: 可以实现某个特定单一功能的服务模块,是 SOA(Service Oriented Architecture) 的产物, 是 SOA 升华的具体体现
          轻量,可复用,便于维护
   微服务架构: 多个相互关联的微服务组成的可以实现完整功能的架构模式

SOA 与 微服务 
总结: 量变引起质变,这就是微服务架构和 SOA 服务化架构的最大差异
    微服务架构强调业务系统需要彻底的组件化和服务化,一个组件就是一个产品,可以独立对外提供服务
    微服务不再强调传统 SOA 架构里面比较重的 ESB 企业服务总线
    微服务强调每个微服务都有自己独立的运行空间,包括数据库资源
    微服务架构本身来源于互联网的思路,因此组件对外发布的服务强调了采用 HTTP Rest API 的方式来进行
    微服务的切分粒度会更小
    微服务架构是 SOA 架构思想的一种扩展,更加强调服务个体的独立性、拆分粒度更小。

微服务的优缺点? (说一下实际应用存在的问题,及解决方案)
   优点:
     每个服务足够内聚, 足够小, 代码容易理解, 这样能聚焦一个指定的业务功能或业务需求.
     开发简单、开发效率提高(微服务能够被小团队单独开发), 一个服务可能就执行某一特定功能.
     微服务是 松耦合的, 是有功能意义的服务, 无论是在开发阶段或部署阶段都是独立的.
     微服务能使用不同的语言开发.
     易于和第三方集成, 微服务允许容易且灵活的方式集成自动部署; 允许融合最新技术.
     微服务易于被一个开发人员理解, 修改, 维护, 这样小团队能够关注自己的工作成果.
     微服务只是业务逻辑代码, 不会和前端代码和其他界面组件混合.
     每个微服务都有自己的存储能力, 可以有自己的数据库.
   缺点:
     开发人员要处理分布式系统的复杂性.
     多服务运维难度, 随着服务的增加, 运维压力增大.
     系统部署依赖.
     服务间通信成本.
     数据一致性.
     系统集成测试.
     性能监控.

微服务技术栈有哪些
eureka 和 zookeeper 都可以提供服务注册于发现的功能

微服务之间是如何独立通讯的
   总的来说,分为以下通信方式 (dubbo 和 cloud 比较)
        dubbo: RPC (remote procedure call) 协议
        cloud: REST 
   具体的细分: (各模块之间) - 进程间的通信(一个服务就是一个进程)
     交互类型:
       一对一通信: 每个客户端请求有一个服务实例来响应
       一对多通信: 每个客户端请求有多个服务实例来响应
     同步异步:
        同步: 客户端请求需要服务端即时响应, 甚至可能由于等待而阻塞
        异步: 客户端请求不会阻塞进程, 服务端的响应可以是非即时的
     客户端到服务端通信: API Gateway(网关) -- eg: zuul
     消息队列(点对点, 发布/订阅)
     
------------------------------------------------------------------------------------------------------------------------

Eureka 与 ZooKeeper
    Eureka 遵守 AP、ZooKeeper 遵守 CP
        淘宝双11肯定是 AP、保证高可用

        服务注册功能的高可用性要求高于一致性,但是 ZK 会出现,
        当 Master 节点因为故障 Down 掉时其它节点重新选举 Leader,但是选举时间太长(30-120秒),
        而选举期间服务是不可用的,这就导致在选举期间整个注册服务瘫痪。

        Eureka 看明白了这一点,因此在设计时就优先保证可用性。
        Eureka 各个节点是平等的,几个节点挂掉不会影响正常节点的工作、剩余节点依然可以提供注册和查询服务。
        Eureka 客户端在向某个 Eureka 注册时如果发现连接失败,则会自动切换到其它节点,只要有一台 Eureka 存在,注册服务就可用(保证高可用性),
            但是查询到的信息可能不是最新的(不保证强一致性)。
        Eureka 的自我保护机制。
        Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况,而不像 ZooKeeper 那样使整个注册服务瘫痪。
    注:
      zookeeper 集群: 服务器数量为 奇数, 更节省资源
          与 zookeeper 选举规则有关: 可用节点数 > 总节点数 / 2
        
    CAP:
        Consistency: 一致性. 
         "all nodes see the same data at the same time",
          即更新操作成功并返回客户端后,所有节点在同一时间的数据完全一致
          一致性又分为: 绝对一致性(时时刻刻保持一致), 最终一致性(牺牲时效性, 常见的就是 转账到账时间)
        Availability: 可用性.  "Reads and writes always succeed",即服务一直可用,而且是正常响应时间。
        Partition tolerance: 分区容错性.  即分布式系统在遇到某节点或网络分区故障的时候,仍然能够对外提供满足一致性或可用性的服务

        CAP 原则(principle): 在一个分布式系统中, CAP 三者不可兼得
            -- 而由于网络传输的问题, 分区容错性 是必须遵守的, 所以只能在 C, A 中做选择
          目前更合适的选择就是, 保证高可用(A), 不求 绝对一致, 保证 最终一致性 即可.
          如 消息队列的异步解耦, 实际上就可以认为是 最终一致性.

                      eureka                     zookeeper
        CAP         保证高可用性(AP)              保证数据一致性(CP)
        持久化       不持久化,节点信息放内存        持久化到磁盘
        更新通知     通过增量更细注册信息           通过 watch 事件来监控节点变化
        缓存         提供客户端缓存                无缓存
        适用场景     适合作为服务注册中心           适合做分布式协调服务

Spring Boot 和 Spring Cloud 比较
    Boot 就是 "启动(引导)" 的意思. Spring Boot 作为 微服务快速配置的脚手架.
    Spring Cloud 基于 Spring Boot,为微服务体系开发中的架构问题,提供了一整套的解决方案——服务注册与发现,服务消费,服务保护与熔断,网关,分布式调用追踪,分布式配置管理等。
    Spring Boot 专注于快速、方便集成的单个个体,Spring Cloud是关注全局的服务治理框架;
    spring Boot 遵循 "约定优于配置" (Convention Over Configuration) 的理念,很多集成方案已经帮你选择好了,能不配置就不配置,
    Spring Cloud很大的一部分是基于Spring boot来实现。
    
什么是服务熔断, 什么是服务降级
  https://blog.csdn.net/hongwei15732623364/article/details/82078739
  https://blog.csdn.net/hongwei15732623364/article/details/82078704
  熔断这一概念来源于电子工程中的断路器(Circuit Breaker)。通俗的说,就是 "保险丝".
     在互联网系统中,当下游服务因访问压力过大而响应变慢或失败,
    上游服务为了保护系统整体的可用性,可以暂时切断对下游服务的调用。这种牺牲局部,保全整体的措施就叫做熔断。
  如果没有 熔断机制, 一个服务的不可用, 会引起其他关联服务的 "雪崩效应"(调用链路的连锁故障).

  Hystrix 的三种熔断状态：
  1.熔断关闭状态 (Closed)
    服务没有故障时,熔断器所处的状态,对调用方的调用不做任何限制。
  2.熔断开启状态 (Open)
     在固定时间窗口内(Hystrix默认是10秒),接口调用出错比率达到一个阈值(Hystrix默认为50%),会进入熔断开启状态。
     进入熔断状态后,后续对该服务接口的调用不再经过网络,直接执行本地的fallback方法。
  3.半熔断状态 (Half-Open) 
    在进入熔断开启状态一段时间之后(Hystrix默认是5秒),熔断器会进入半熔断状态。
    所谓半熔断就是尝试恢复服务调用,允许有限的流量调用该服务,并监控调用成功率。
    如果成功率达到预期,则说明服务已恢复,进入熔断关闭状态; 如果成功率仍旧很低,则重新进入熔断关闭状态。

 服务降级:
     当服务器压力剧增的情况下,根据当前业务情况及流量对一些服务和页面有策略的降级,以此释放服务器资源以保证核心任务的正常运行。
     给 使用率较低的服务设置较低的权重, 给使用率较高的服务设置较高的权重
 解决方案：
     服务接口拒绝服务：页面能访问,但是添加删除提示服务器繁忙。页面内容也可在 Varnish 或 CDN 内获取。
     页面拒绝服务：页面提示由于服务繁忙此服务暂停。跳转到 varnish 或 nginx 的一个静态页面。
     延迟持久化：页面访问照常,但是涉及记录变更,会提示稍晚能看到结果,将数据记录到 异步队列 或 log ,服务恢复后执行。
     随机拒绝服务：服务 接口随机 拒绝服务,让用户重试,目前较少有人采用。因为用户体验不佳。

----------------------------------------------------------------------------------------------------------------------

Ribbon和Feign的区别
    Ribbon和Feign都是用于调用其他服务,不过方式不同。
    1、启动类使用的注解不同,Ribbon使用的是 @RibbonClient,Feign用的时 @EnableFeignClients
    2、服务的指定位置不同,Ribbon是在 @RibbonClient 注解上声明,Feign则是在定义抽象方法的接口使用@FeignClient声明。
    3、调用方式不同,Ribbon需要自己构建http请求,模拟http请求然后使用RestTemplate发送给其他服务,步骤相当繁琐。
       Feign则是在Ribbon的基础进行了一次改进,采用接口的方式,将需要调用的其他服务的方法定义成抽象方法即可。
       不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。

SpringCloud 断路器的作用
     当一个服务调用另一个服务由于网络原因或者自身原因出现问题时, 调用者就会等待被调者的响应,
     当更多的服务请求到这些资源时, 导致更多的请求等待, 这样就会发生连锁效应, 断路器就是解决这一问题的。
     断路器有完全打开状态:
         一定时间内,达到一定的次数无法调用,并且多次检测没有恢复的迹象,断路器完全打开,那么下次的请求不会请求到该服务。
     半开:
         短时间内有回复迹象,断路器会将部分请求发送给服务,当能正常调用时,断路器关闭。
     关闭:
         当服务一直处于正常状态,能正常调用,断路器关闭。




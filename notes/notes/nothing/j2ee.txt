EJB： enterprise javabean
JTA： java transaction API
GC：
	A．串行回收（Serial）和并行回收（Parallel）：串行回收就是不管系统有多少个 CPU，
		始终只用一个 CPU 来执行垃圾回收操作；而并行回收就是把整个回收工作拆分成多部分，
		每个部分由一个 CPU 负责，从而让多个 CPU 并行回收，并行回收的执行效率很高，但复杂
		度增加，另外也有其他一些副作用，比如内存碎片会增加。
	B．并发执行（Concurrent）和应用程序停止（Stop-the-world）：。Stop-the-world 的垃圾
		回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致
		应用程序的暂停，但由于并发执行垃圾回收需要解决和应用程序的执行冲突（应用程序可能
		会在垃圾回收的过称中修改对象），因此并发执行垃圾回收的系统开销比 Stop-the-world 更
		好，而且执行时也需要更多的堆内存。
	C．压缩（Compacting）和不压缩（Non-compacting）和复制（Copying）：为了减少内
		存碎片，支持压缩的垃圾回收器会把所有的活对象搬迁到一起，然后将之前占用的内存全部
		回收。不压缩式的垃圾回收器只是回收内存，这样回收回来的内存不可能是连续的，因此将
		会有较多的内存碎片。较之压缩式的垃圾回收，不压缩式的垃圾回收回收内存快了，而分配
		内存时就会更慢，而且无法解决内存碎片的问题。复制式的垃圾回收会将所有可达对象复制
		到另一块相同的内存中，这种方式的优点是垃圾及回收过程不会产生内存碎片，但缺点也很
		明显，需要拷贝数据和额外的内存。
		
内存泄漏：
	程序运行过程中不断分配内存空间， 那些不再使用的内存空间应该即时回收它们，
	从而保证系统可以再次使用这些内存。如果存在无用的内存没有被回收回来，就是内存泄漏。
	
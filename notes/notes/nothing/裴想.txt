复习路线
写在前面：给大家总结的，希望大家认真对待，将下面的知识点一个一个搞懂。

java基础:
jvm:简单的如内存划分,堆栈的区别,gc机制,跨平台性,jvm调优,内存溢出等
java se:包含
集合:list,set,map的存储特点,底层数据结构,HashMap的底层原理等
多线程:线程和进程区别,线程开启的方式,线程同步,死锁,线程通信.经典售票案例
其他:面向对象(谈谈理解,多态),异常(finally相关问题,常见异常),常见的IO流,网络编程七层架构.反射,记住Object和String常用方法
简单的算法和数据结构,比如排序,查找,数组反转,递归,数组,链表,堆栈,队列,树等
Java web:
前端:js/jQuery常用方法和事件,ajax原理
Web基础:servlet生命周期,jsp内置对象,tomcat优化,cookie和session,filter和intercepter区别,
数据库:dql语句编写,sql的优化,事务及隔离级别,存储过程,oracle对象
框架:spring的IOC/DI和AOP,事务管理,springMVC执行流程,常用注解,springboot相关,springcloud相关，hibernate和mybatis的区别,一二级缓存和快照,hibernate的延迟加载和优化等细节. mybatis常用标签.

技术点:
Linux基本命令（脱口而出至少五个）
Redis存储数据类型和命令,持久化机制,集群相关,使用场景
ActiveMQ中间件(原理,好处,使用场景,怎样防止数据丢失)
Nginx和WebService(如何使用,优缺点)了解
Dubbo(原理)和zookeper(作用,以及其替代品)
Solr/elasticsearch 相关(原理,怎么存,怎么取,索引同步,io阻塞)
angularJS四大特性,基本指令
shiro/spring security原理,五张表及字段,授权,配置相关
常见的设计模式,相关应用场景

项目(弱点，这里需要花时间，克服心中的恐惧)
搜索,权限,订单,单点登录,购物车,商品管理,支付,集群等
思路清晰地说出业务逻辑,涉及到的表,使用到的技术,项目的难点和收获

其它问题:
1,项目中遇到最难的问题,怎么解决的?
2,项目周期及人力配置
3,你的优点和缺点
4,为什么转行java开发


面试时可以反问面试官的问题
1，我注意到你们使用了X技术，请问你们是如何解决Y问题的？
2，为什么你们的产品使用了X技术而不是Y技术？据我所知，X技术虽然有A、B、C等好处，但也存在D和E问题，而Y技术可以解决D和E问题。
3，我对您说的X技术不是太熟悉，但我感觉它是一个不错的解决方案，您能多讲讲它的工作原理吗？
4，你们团队是如何进行项目规划的？一周会有几次例会？每周的代码量大概是多少？
就X问题我能想到的解决方案目前就只有Y了，请问您会怎么解决这个问题？


面试总结：http://www.chenjin.net.cn/?tdsourcetag=s_pcqq_aiomsg

为什么大多数人愿意吃生活的苦也不愿意吃学习的苦？因为学习的苦是主动的，而生活的苦，躺着就来了


请大家详细阅读这个文档，认真思考，如有不理解，随时call我。
项目介绍
首先要让别人知道你这是个什么项目，是用来干嘛的。接着就是项目的主体架构，如果不会用术语来描述，请百度。接着就是说明项目大体分为哪些模块，你自己负责了什么模块，这是重点，首先要告诉别人这个模块的业务逻辑是怎么样的，是怎么去完成功能的，接着是用了什么技术去实现（如果涉及前端展示，用一两句话描述大体的布局，会有一种带入感，增加真实感）期间面试官会针对你的业务逻辑描述和技术实现对你进行提问。需要准备的是对业务的了解，对数据传递的了解，对该技能的了解，对该模块涉及的表（大致说几张表就可以）的了解。最后，一两句话描述一些你做这个项目的收获，或者加上在完成你的责任模块是遇到的困难，以及解决办法；

一个项目介绍的成功与否，很大程度取决于是否让别人觉得很真实，要素：描述流畅、业务清晰（可以多用专业的名词）、有画面感、表关系知道一些、做完有收获。
如果你能做到以上的要求，那么你的项目介绍基本就OK了~
一、项目简介
网上阅卷是近年来随着网络技术、计算机技术、信息数字化技术、图形图像处理技术的快速发展而出现的基于网络的考试阅卷系统。由于现在教育考试的侧重点在于对学生创新意识和实践能力的考察上，因此试卷中主观题数量大大增加，但是主观题的评阅容易受到多方面因素的影响，难以保证考试的公平性，网上阅卷通过将考生的试题数字化，存储在相应的计算机系统中，通过对试卷试题信息进行分割、切分处理，分离出单一考题。在教师阅卷时，将考题直接显示在计算机屏幕上，由教师在屏幕上阅卷和给分。对教师给出的分数根据误差控制原理进行多平均取值，尽可能避免了因某一评卷老师疏忽而给出的错误分数，保证考试的公平公正。
相对与传统的手工阅卷方式，有以下几个明显的优点：
1）由于将考生的试卷数字化存储和流通，减轻了保存机密档案的压力。
2）拓展了阅卷工作的参与面。采用网上阅卷的形式，可以利用网络在时间、空间上拓展阅卷工作，邀请一些远在外地的高级教师、专家参加阅卷，提升阅卷的水平。
3）答卷在数字化时，仅保留考生的答案，并将考号映射成为了一组无意义的字符串，提高了保密性。
4）网上评阅的试卷将回经过多人评阅，并进行误差纠正，避免了一阅定终生的情况，提高了安全性与阅卷质量。
5）网上阅卷对阅卷过程进行了精简，提高了工作效率和准确度。
这部分是教大家去了解一个项目，在去面试的时候不需要这么细致，但是在准备的时候应该要有这么充分。
二、责任模块
网上阅卷系统是一个软硬件结合的系统，我主要负责其中的软件设计，这个系统主要分为试卷图片处理、客观题评卷、主观题评卷、系统管理以及安全保密模块，采用的是ssm框架来实现的。我在这次的系统中主要负责主观题评卷模块和安全控制模块的设计与实现，这两个模块主要分为几个小模块：身份认证与访问控制模块、任务分发模块、主观题评分模块和消息交互模块。

非自己的责任模块，可以稍微模糊点，但是在说到自己负责的模块的时候，一定要有很清晰的思维；
3.1、身份认证与访问控制模块
在系统中为了实现网阅系统的统一身份认证和访问控制，我使用了shiro进行权限管理。通过应用程序代码调用Subject的API，所有的Subject都绑定到SecurityManager（安全管理器），SecurityManager要验证用户身份，那么他需要从Realm获取相应的用户进行比较以确定用户身份是否合法。这个系统权限相关的操作都是由超级管理员完成的，整个系统只有一个超级管理员。通过超级管理员来给予每个评卷教师不同的权限，根据权限的不同来让每个评卷老师各司其职。
在超级管理员角色下可以添加新的角色给角色赋予权限，超级管理员将评卷老师分为管理员、大组长、小组长、普通评卷教师几个角色，在超管添加好一个角色并赋予权限提交表单，服务器接收到请求后将该角色保存并关联对应的权限。评卷客户端程序是超级管理员、管理员、大组长、小组长、普通评卷教师都可以直接接触的用户界面。评卷客户端通过web服务器进行身份认证，管理员初始化系统。请求客户端的相应任务，完成试卷的评阅。大、小组长实时监控现场评阅教师的评卷数量和质量、进度统计、异常试卷的处理。客户端无法直接访问评卷数据库，只能调用阅卷的Web服务器来实现功能，以保证系统及数据的安全性。
该系统的系统菜单是动态的菜单，根据登录角色的权限来显示不同的有权限的菜单，前端获取当前登录的用户通过session中用户的id，在后端判断用户的角色和权限，如果是超管则拥有所有菜单，其他角色则根据自己的权限显示菜单。

3.2、任务分发模块

任务分发模块是系统的关键环节，可以说这个模块设计的好坏直接决定这系统的成败与否。这个模块必须处理好三个问题：（1）任务必须随机分发；（2）杜绝任务被重复评阅；（3）杜绝每次都只取同一种类型的任务（如一评、二评、三评任务）。
在任务列表中，试题的排列顺序是根据扫描的顺序排列的，都是一次性把某个地区扫描完。为了避免某些老师因地区的不同而给出的分数有所偏差（比如在评阅自己地区的试卷给的分数相对高些），该系统必须做到任务分发。在这个系统中，我通过系统生成一个随机数，使得任务按随机数来取，从而打乱了任务的次序，做到随机分发。
大部分试题都是至少需要二评才能给出最终分数的。在评卷过程中，租场监控着评卷的任务进度。为了更好的监控评卷员的评阅尺度把握情况，我们就不能让系统某一段时间只分发同一类型的任务。该系统按照1/3的概率来分发三评卷，让组长更好的比较评卷员的评阅情况。

3.3、主观题评分模块

主观题评分模块也是网上阅卷系统的核心模块之一。教师在阅卷终端上对试卷的评阅工作，包括正评、回评、仲裁、问题卷、雷同卷标记等处理都是客户端软件与阅卷服务中评卷子模块协同工作的结果。每份试卷所得分数都是由阅卷客户端提交并交由评卷子模块处理产生，误差控制也是对评卷子模块处理后的分数进行检查和判断。
3.3.1普通阅卷老师的工作流程
1）阅卷老师在登录并获取相关权限后，系统根据用户的权限和当前系统状态和评阅员状态，按考场随机分发一定的任务，如果处于正式开始前的试评阶段，则直接从试评库中获取任务给阅卷员；如果是正评状态，则从任务列表t_task_list中按考场随机分发一定的任务存入分发列表task_queue中。
2）评卷老师在研究了考卷图片后，根据自己的专业判断给出评分，由客户端程序调用阅卷服务中分数提交处理子流程进行处理。分数提交处理子流程根据提交的试卷类型对试卷做出标记问题卷，记录此次评卷分数，评判阅卷员工作质量，并在需要时切换工作状态等处理，完成一份试卷的评阅工作。
3）提交任务时，判断评阅状态。如果是试评则进入试评处理阶段，任务提交到试评列表，如果提交过后任务列表为空，则比对评卷员状态与系统状态是否相同，不同就切换评卷员状态；如果是正评阶段，则按正常提交分数、问题卷标记、雷同卷标记、回评卷进行处理。
4）提交任务后，根据系统设定的复评频度，判断该评卷员是否到达系统设定的自评点，如果到达则从复评表t_remark中去任务设为下一份要评的卷子，并将当前试卷加入到复评表中。

在描述项目模块的时候，适当加入表名，会有意想不到的好处~
3.3.2异常卷处理
评卷员在评阅过程中，可能回出现异常的试卷不能给出正确的分数，需要对试卷做标记，交给大组长火小组长来处理。主要包括问题卷和雷同卷两种类型。
1）问题卷处理
问题卷主要包括三种类型：打错题；图像不清；其他问题。评卷员在试卷上标注后提交给组长处理。
2）雷同卷处理
如果两个或者多个试卷的答案类似或者完全相同，由抄袭作弊的嫌疑，可以通过该功能将涉嫌作弊的试卷提交给系统，等待判定。

3.3.3复评卷处理
为监控每位教师评阅试卷的给分尺寸是否保持一致，系统设置了个人复评功能，根据系统设置复评频度，每位老师每评阅一定数量的试卷将自动从已评阅的试卷中取一份试卷进行重新评阅，也就是说教师在不同的时间里面可能评阅同一份试卷，如果两次的给分差距较大，则可以说明老师给分是随意的没有认真评阅试卷，这样组长就可以很好的监控评卷员的评阅尺度的把握情况。

3.4消息交互模块
由于该系统的用户量很大，因此必须对高并发问题进行处理，这里我们采用了分布式开发。创建maven工程将这个系统按照业务分模块分层开发，利用Dubbox来进行远程服务调用来完成消息交互的过程。sevice层作为提供者在启动时注册服务地址，web层作为消费者在启动时订阅服务地址，在变更时推送服务地址列表，然后随机调用一个服务地址，失败重试另一个地址。Dubbox还有一个监听器在后台定时采集服务调用次数和调用时间等信息。在评阅过程中，组长必须掌握普通评卷员的进度，调控普通评卷教师的评卷尺度等。数据统计分析模块主要为组长的工作提供依据，并为阅卷后期选拔优秀评卷教师提供一句。该模块主要完成显示当前任务情况，教师评阅试卷吻合指数和评卷数量、给分情况、每日进度等信息。通过对以上信息数据的维护来完成数据的统计分析。
针对同一份试卷的同一道题计算吻合指数我使用的是每位评卷老师所评的分数与最终分数的差距作为指标，用于评价阅卷教师评阅试卷的质量。指数越高则表明越接近最终分数，评卷质量越高。

下面附上一些专业技能的描述，大家花点时间看一下，特别是自己项目涉及到的责任模块里面包含的技术~
三、专业技能
Spring Data：
Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。 Spring Data 包含多个子项目：
1）Commons - 提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化
2）JPA - 简化创建 JPA 数据访问层和跨存储的持久层功能
3）Hadoop - 基于 Spring 的 Hadoop 作业配置和一个 POJO 编程模型的 MapReduce 作业
4）Key-Value  - 集成了 Redis 和 Riak ，提供多个常用场景下的简单封装
5）Document - 集成文档数据库：CouchDB 和 MongoDB 并提供基本的配置映射和资料库支持
6）Graph - 集成 Neo4j 提供强大的基于 POJO 的编程模型
7）Graph Roo AddOn - Roo support for Neo4j
8）JDBC Extensions - 支持 Oracle RAD、高级队列和高级数据类型
9）Mapping - 基于 Grails 的提供对象映射框架，支持不同的数据库
10）Examples - 示例程序、文档和图数据库
11）Guidance - 高级文档

Spring Data JPA：
Spring Data JPA是由Spring提供的一个用于简化JPA开发的框架
Spring Data JPA可以极大的简化JPA的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。
主要来看看Spring Data JPA提供的接口，也是Spring Data JPA的核心概念：
1）Repository：最顶层的接口，是一个空的接口，目的是为了统一所有Repository的类型，且能让组件扫描的时候自动识别。
2）CrudRepository ：是Repository的子接口，提供CRUD的功能。
3）PagingAndSortingRepository：是CrudRepository的子接口，添加分页和排序的功能
4）JpaRepository：是PagingAndSortingRepository的子接口，增加了一些实用的功能，比如：批量操作等。
5）JpaSpecificationExecutor：用来做负责查询的接口。
6）Specification：是Spring Data JPA提供的一个查询规范，要做复杂的查询，只需围绕这个规范来设置查询条件即可。

Shiro：
Shiro是apache下面的一个开源项目，较之Spring Security，Shiro在保存强大功能的同时，还在简单性和灵活性方面拥有巨大优势。
Shiro是一个强大且易于使用的Java安全框架，他具有认证、鉴权、加密、会话管理等功能。
Shiro运行原理：

Application Code:应用程序代码，就是我们自己的编码，如果在程序中需要进行权限控制，需要调用Subject的API。
Subject:主体，代表的了当前用户。所有的Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager,可以将Subject当成一个门面，而真正执行者是SecurityManager。
SecurityManage:安全管理器，所有与安全有关的操作都会与SecurityManager交互，并且它管理所有的Subject。
Realm:域 shiro是从Realm来获取安全数据（用户，角色，权限）。就是说 SecurityManager要验证用户身份， 那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作； 可以把 Realm 看成 DataSource，即安全数据源。
Shiro为程序共提供了四种权限控制方式：
1）url级别权限控制
2）方法注解权限控制
3）代码级别权限控制
4）页面标签权限控制
Spring Security：
Spring Security是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了Spring IOC，DI（IOC:控制反转 Inversion of Control ,DI:Dependency Injection 依赖注入）和 AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。
Dubbox：
Dubbox 是一个分布式服务框架，其前身是阿里巴巴开源项目 Dubbo ，被国内电商及互联网项目中使用，后期阿里巴巴停止了该项目的维护，当当网便在 Dubbo 基础上进行优化，并继续维护，为了与原有的 Dubbo 区分，故将其命名为 Dubbox。
Dubbox 致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。简单的说，dubbox 就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有 dubbox 这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。
Dubbox的运行流程：


运行流程说明：
0. 服务容器负责启动，加载，运行服务提供者。
1. 服务提供者在启动时，向注册中心注册自己提供的服务。
2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

Dubbox的注册中心官方推荐使用 zookeeper册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。
Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbox 服务的注册中心，工业强度较高，可用于生产环境。

WebService：
WebService是一种跨编程语言和跨操作系统平台的远程调用技术。所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上
优点：早起非常流行，大公司的弄的，标准的，很容易跨平台，跨语言。设计的时候在网络上传输。
缺点：额外使用soap协议（xml包装-消息太大---解析成本），效率不高，大公司绑架，在开源的时代，很多人抵制它。Webservice	没有集群的支持。
Solr：
Solr 是基于lucene搜索库的一个搜索引擎框架。
1.简单来说所谓的索引是为了全文数据存储和查询准备的，全文数据即非结构化数据，比如一篇文章，如果你要用一般的手段进行搜索的话，比如用数据库的like命令会有不少限制，而且还不能支持一些相同语义的问题。
举个简单的例子，你在亚马逊上面搜索solr，却可以查询出来lucene内容，这就是关联性查询和语义查询。
2、高性能的，上亿条数据通过索引的方式可以秒级查询出来，优化后可能更好。
3、solr将非结构化数据，通过分词、词法分析、过滤停词、语义分析等手段来转成结构化数据，存储为索引，里面有文档概念这个和mysql的一条记录又类似。

4、solr怎么设置搜索结果排名靠前（得分）？
可以设置文档中域的boost值，boost值越高计算出来的相关度得分就越高，排名也就越靠前。此方法可以把热点商品或者是推广商品的排名提高。
5、solr里面IK分词器的原理
IK分析器的分词原理本质上是词典分词。现在内存中初始化一个词典，然后在分词过程中逐个读取字符，和字典中的字符相匹配，把文档中的所有的词语拆分出来的过程。
Elasticsearch：
Lucene就是一套全文检索编程API，基于Lucene对数据建立索引，进行查询。
现代企业开发中，更常用的是solr搜索服务器和ElasticSearch搜索服务器。Elasticsearch的全文检索：针对文本中每个词，创建词条建立索引，进行搜索。Elasticsearch通过Rest API操作服务器上的数据。






Elasticsearch的主要概念：
1）索引对象（数据存在哪？）：存储数据的表结构，任何搜索数据，存放在索引对象上
2）映射（数据怎么存？）：数据如何存放到索引对象上，需要有一个映射配置，数据类型、是否存储、是否分词…
3）文档（存什么数据？）：一条数据记录，存在索引对象上
4）文档类型（数据有哪些类型？）：一个索引对象，存放多种类型数据，数据用文档类型进行标识
编程步骤：
1）建立索引对象
2）建立映射
3）存储数据【文档】
4）指定文档类型进行搜索数据【文档】
Redis：
因为Redis不用SQL语句，也叫NOSQL数据库
数据与数据之间没有关系，是非关系型数据库。
是一个内存数据库：因为把“所有”数据放入内存
	是一个单线程（同一时间内，只能执行一个命令）
	有事务问题。
	支持持久化操作：RDB（内存快照）,AOF（日志）
	最基本的形式是Key-Value形式
	支持的类型有五种：
	String，List，Set，Hash，ZSet
Ehchache：
EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。
EhCache主要的特性有：
1. 快速
2. 简单
3. 多种缓存策略
4. 缓存数据有两级：内存和磁盘，因此无需担心容量问题
5. 缓存数据会在虚拟机重启的过程中写入磁盘
6. 可以通过RMI、可插入API等方式进行分布式缓存
7. 具有缓存和缓存管理器的侦听接口
8. 支持多缓存管理器实例，以及一个实例的多个缓存区域
9. 提供Hibernate的缓存实现
ActiveMQ：
Activemq在项目中主要是完成系统之间通信，并且将系统之间的调用进行解耦。例如在添加、修改商品信息后，需要将商品信息同步到索引库、同步缓存中的数据以及生成静态页面一系列操作。在此场景下就可以使用activemq。一旦后台对商品信息进行修改后，就向activemq发送一条消息，然后通过activemq将消息发送给消息的消费端，消费端接收到消息可以进行相应的业务处理。
1）ActiveMQ是一种JMS Provider，其他开源JMS供应商还有RabbitMQ、RocketMQ。JMS:Java Message Service，一套处理消息的规范。Message：消息，通俗来讲，是指要做的事情。
2）ActiveMQ是一种消息队列技术
Active是活跃的意思，MQ是Message Queue，即消息队列，说通俗点，这个技术能同时处理很多个消息，能同时干很多事。
使用消息队列的好处：
消息队列在大型电子商务类网站，如京东、淘宝、去哪儿等网站有这深入的应用，队列的主要作用是消除高并发访问高峰，加快网站的响应速度。
在不使用消息队列的情况下，用户的请求数据直接写入数据库，在高并发的情况下，会对数据库造成巨大的压力，同时也使得系统响应延迟加剧。
在使用队列后，用户的请求发给队列后立即返回（当然不能直接给用户提示订单提交成功，京东上提示：您“您提交了订单，请等待系统确认”），再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列的服务处理速度远快于数据库，因此用户的响应延迟可得到有效改善。
1、系统整合：同构/异构系统整合，分布式环境中
2、降低模块间耦合：比如AB两个系统，A性能瓶颈或宕机、
系统差不干扰B
3、实现异步:1.推消息 2.削峰请求
4、数据同步:web应用->缓存，搜索，db
FastFDS：
FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用
FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。
Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将 storage 称为存储服务器。
服务端两个角色：
Tracker：管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
Storage：实际保存文件   Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。
Restful：
1、	什么是Restful风格
Representational State Transfer
一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。
在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。
2、	Restful风格好处
1）	基于这种风格架构，软件编写可以更简洁
2）	基于HTTP协议，支持多种消息格式，比如XML、JSON
3）更容易实现缓存机制（第一次访问资源缓存到本地，第二次访问资源，返回304，客户端调用本地）200、 500 、404、304


3、	小结：访问服务器统一资源，采用不同HTTP协议请求方式，服务器端可以得知进行CRUD哪个操作
POST请求方式访问		保存操作（增，英文：Create）
DELETE请求方式访问		删除操作（删，英文：Delete）
PUT 请求方式访问			修改操作（改，英文：Update）
GET请求方式访问			查询操作（查，英文：Retrieve）
Apache POI 报表技术：
一、简介：
Apache POI 是创建和维护操作各种符合Office Open XML（OOXML）标准和微软的OLE 2复合文档格式（OLE2）的Java API。用它可以使用Java读取和创建,修改MS Excel文件.而且,还可以使用Java读取和创建MS Word和MSPowerPoint文件。Apache POI 提供Java操作Excel解决方案。
二、优点:
效率高
支持公式，宏，一些企业应用上会非常实用
能够修饰单元格属性
支持字体、数字、日期操作
三、缺点:
不成熟,代码不能跨平台，貌似不少同行在使用工程中还碰到让人郁闷的BUG（最近的项目中也是遇到了一些bug，不过目前没有查出来是代码的问题还是POI的问题，总之问题很诡异，数据替代参数总有失败的。关于不能跨平台这一说，我也没有试验过，不过Java不是跨平台吗？POI是JAVA的一个组件，怎么就不能跨平台了呢，总之这些问题还需要在以后的项目中多多实践，才能比较出区别之处。）
POI实现模板打印
    我们系统根据用户习惯，采用excel方式，作为业务输出打印。打印时POI是有问题，打印时代码量非常大，样式代码非常多，（常保存，样式和字体对象创建过多）。打印时非常难控制。我进行改造，我使用模板来开发，在模板中定义列宽（POI操作列宽时有BUG，计算非常繁琐），还可以定义静态文件，例如标题部分等静态文字的内容，打印纸质方向，打印页面标题，页眉页脚，都可以在模板中设置。首先无需记忆复杂特殊api。设置字体、样式也可以直接在模板中定义。打印时先读取模板，只处理业务数据的打印即可。
POI海量数据导出系统中备份数据和恢复数据。
    操作excle主要有jxl和poi两种方式，jxl在处理数据时比早期的poi快。（poi早期对象，处理时都是将加工的数据存放在内存中，如果数据量很多，很容易造成堆溢出，同时它占用CPU和大量内存，导致其他业务也无法正常完成。）poi在新版本中改善这个性能瓶颈。对大数据量的导出做了优化。
    使用ooxml技术，使用SXSSF对象，当数据创建到指定数量时，自动写缓存，将它内容输出到临时文件中。这个临时文件是一个xml，相比内存中对象的结构非常简单。只保留数据的信息。保存的数据量也非常少。这样就可以形成大数量的导出。例如：杰信项目中，购销合同业务，它有很多历史信息，积累了很多年，数据量达到近百万。导致系统变慢，我们采用poi导出数据备份到excel文件中。将这部分历史信息从当前表删除。在打印中就可以直接实现。（excel单sheet可以支持1048576）。
AngularJS：
一、AngularJS简介
AngularJS  诞生于 2009 年，由 Misko Hevery 等人创建，后为 Google 所收购。是一款优秀的前端 JS 框架，已经被用于 Google 的多款产品当中。AngularJS 有着诸多特性，最为核心的是：MVC、模块化、自动化双向数据绑定、依赖注入等等。
二、AngularJS四大特征
1、MVC模式
Angular 遵循软件工程的 MVC 模式,并鼓励展现，数据，和逻辑组件之间的松耦合.通过依赖注入（dependency injection），Angular 为客户端的 Web 应用带来了传统服务端的服务，例如独立于视图的控制。 因此，后端减少了许多负担，产生了更轻的 Web 应用。
2、双向绑定
AngularJS 是建立在这样的信念上的：即声明式编程应该用于构建用户界面以及编写软件构建，而指令式编程非常适合来表示业务逻辑。框架采用并扩展了传统 HTML，通过双向的数据绑定来适应动态内容，双向的数据绑定允许模型和视图之间的自动同步。因此，AngularJS 使得对 DOM 的操作不再重要并提升了可测试性。
3、依赖注入
依赖注入(Dependency Injection,简称 DI)是一种设计模式, 指某个对象依赖的其他对象无需手工创建，只需要“吼一嗓子”，则此对象在创建时，其依赖的对象由框架来自动创建并注入进来,其实就是最少知识法则;模块中所有的 service 和 provider 两类对象，都可以根据形参名称实现 DI.
4、模块化设计
高内聚低耦合法则
1）官方提供的模块       ng、ngRoute、ngAnimate
2）用户自定义的模块     angular.module('模块名',[ ])
为什么用$http?  因为我们要用ajax
1.引入$http
app.controller("myappController",function($scope,$http){
2.$http有请求方法：get post
var obj = $http.get('url');
3.调用成功
obj.success(
function(response){
$scope.list=response;
}
);
AOP（面向切面编程）：
AOP为面向切面编程的缩写,利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。Spring的AOP为动态AOP，实现的技术为：JDK提供的动态代理技术和CGLIB动态代理
第一步:编写目标对象(target)
第二步:编写通知(advice)增强目标对象
第三步:在配置文件中配置切面(切面=切点+通知)
第四步:测试
AspectJ框架它定义的通知类型有6种
1.前置通知Before 相当于BeforeAdvice
2.后置通知AfterReturning 相当于AfterReturningAdvice
3.环绕通知 Around 相当于MethodInterceptor
4.抛出通知AfterThrowing 相当于ThrowAdvice
5.引介通知DeclareParents 相当于IntroductionInterceptor
6.最终通知After 不管是否异常，该通知都会执行
四、五大框架
Struts2：
Struts2的执行流程：


StrutsPrepareAndExecuteFilter是Struts2的核心控制器，它采用前端控制器模式，对用户的请求进行控制处理。
Struts2可复用的代码功能都是基于Interceptor（拦截器）来实现的。struts2有很多内置拦截器，用来实现不同的功能。
Action是执行具体的业务逻辑代码的，它在拦截器之后执行。

Struts2与SpringMVC的区别
Springmvc的入口是一个servlet即前端控制器，而Struts2入口是一个filter过虑器；
Springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例；
Struts2采用值栈存储请求和响应的数据，通过OGNL存取数据，Springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用JSTL。

Hibernate：
1、Hibernate的执行流程
通过Configuration.configure()读取并解析hibernate.cfg.xml配置文件；
由hibernate.cfg.xml中的<mapping resource=”com/xx/User.hbm.xml”/>读取并解析映射信息；
通过config.buildSerssionFactory()创建SessionFactory;
sessionFactory.openSession()打开session；
session.beginTransaction()创建事务transation；
persistent operate（持久化操作）；
session.getTransaction().commit()提交事务；
关闭session;
关闭SessionFactory。
2、Hibernate与Mybatis的区别
1.Mybatis是把sql语句与java代码分离了，sql语句在xml文件配置;
2.Hibernate是ORM框架,它对JDBC进行了封装,在分层结构中处于持久化层，它能建立面向对象的域模型和关系数据模型之间的映射,它大大简化了dao层的编码工作;

Spring：
1、Spring的理解
spring是一个开源框架，Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC和AOP容器框架。

2、Spring主要核心是：
(1)控制反转(IOC)：传统的java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象，而在Spring开发模式中，Spring容器使用了工厂模式为我们创建了所需要的对象，我们使用时不需要自己去创建，直接调用Spring为我们提供的对象即可，这就是控制反转的思想。实例化一个java对象有三种方式：使用类构造器，使用静态工厂方法，使用实例工厂方法，当使用spring时我们就不需要关心通过何种方式实例化一个对象，spring通过控制反转机制自动为我们实例化一个对象。

依赖注入(DI)：Spring使用Java Bean对象的Set方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程就是依赖注入的基本思想。

(3)面向切面编程(AOP)：在面向对象编程(OOP)思想中，我们将事物纵向抽象成一个个的对象。而在面向切面编程中，我们将一个个对象某些类似的方面横向抽象成一个切面，对这个切面进行一些如权限验证，事物管理，记录日志等公用操作处理的过程就是面向切面编程的思想。
在Spring中，所有管理的对象都是JavaBean对象，而BeanFactory和ApplicationContext就是spring框架的两个IOC容器，现在一般使用ApplicationContext，其不但包含了BeanFactory的作用，同时还进行更多的扩展。

3、Spring Bean生命周期
1.Spring容器 从XML 文件中读取Bean的定义，并实例化Bean。
中间省略(很复杂)
如果bean实现了 DisposableBean，它将调用destroy()方法。

9、几种比较重要的注解类型：
@Required：该注解应用于设值方法。
@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。
@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。

10、Spring事务
Spring支持两种类型的事务管理：
1.编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。
2.声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。

4、Spring 中的设计模式
1.代理模式—Spring中两种代理方式，若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理，若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。
2.单例模式—在spring配置文件中定义的bean默认为单例模式。
3.模板方法模式—用来解决代码重复的问题。
    比如： RestTemplate, JmsTemplate, JpaTemplate。
4.前端控制器模式—Srping提供了DispatcherServlet来对请求进行分发。
5.视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。
6.依赖注入—贯穿于BeanFactory/ApplicationContext接口的核心理念。
7.工厂模式—在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。Spring中使用BeanFactory用来创建对象的实例。

SpringMVC：
SpringMVC执行流程描述：(很麻烦,很复杂)
1. 用户向服务器发送请求，请求被SpringMVC 前端控制器DispatcherServlet捕获；
2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；
3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler方法）
4.  提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，SpringMVC将帮你做一些额外的工作：
HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息。
数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。
数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。
数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。
5.  Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
6.  根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到SpringMVC容器中的ViewResolver)返回给DispatcherServlet；
7. ViewResolver 结合Model和View，来渲染视图；
8. 将渲染结果返回给客户端。

SpringMVC的注解
1.@Controller
@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。
2.@RequestMapping
@RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
3.@Resource和@Autowired
@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。
相同点：两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。
不同点：
@Autowired为Spring提供的注解，需要导入包
org.springframework.beans.factory.annotation.Autowired；
@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：
public class TestServiceImpl {
    @Autowired
    @Qualifier("userDao")
    private UserDao userDao;
}
2) @Resource
@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。
注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。
4.@ModelAttribute和 @SessionAttributes
@ModelAttribute该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。
 @SessionAttributes即将值放到session作用域中，写在class上面。
5.@PathVariable
用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。
6.@requestParam
@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter("name")，它有三个常用参数：defaultValue = "0", required = false, value = "isApp"；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。
7.@ResponseBody
作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。
使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；
8.@Component
相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。
9.@Repository
用于注解dao层，在daoImpl类上面注解。
Mybatis：
Mybatis的理解
MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。
Mybatis的优点：
1、简单易学。mybatis本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar加配置几个sql映射文件，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现；
2、灵活。mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多；
3、解除sql与程序代码的耦合。通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性；
4、提供映射标签，支持对象与数据库的orm字段关系映射；
5、提供对象关系映射标签，支持对象关系组建维护；
6、提供xml标签，支持编写动态sql。
动态sql：
a.判断，使用test属性
<if test="id!=null">
and id=#{id}
</if>
b.where可以过滤无效的"and"
<where>
<if test="id!=null">
and id=#{id}
</if>
<if test="username != null and username != ''">
and username like '%${username}%'
</if>
</where>
c.循环遍历
<foreach collection="ids" item="id" open="and id in(" close=")" separator=",">
  #{id}
</foreach>
d.抽取公共的sql语句片段，通过id来定义唯一性
<sql id="find_user_list_where">
  <where>
   <if test="id!=null">
     and id=#{id}
   </if>
   <if test="username != null and username != ''">
     and username like '%${username}%'
   </if>
  </where>
</sql>
e.引入公共的sql语句，refid来引入
<include refid="find_user_list_where"/>






2019年9月6日 22点21分
1. variables must have a type.
2. variables must have a name.

primitive 数据类型:
 byte     8 bits        -128 ~ 127
 short    16 bits       -32768 ~ 32767
 int      32 bits       -2147483648 ~ 2147483647
 long     64 bits       ---
 float    32 bits       可变
 double   64 bits       可变
 char     16 bits       0 ~ 65535
 boolean  虚拟机决定    true/false

封装: encapsulation
   实例变量标记为 private, getters/setters 标记为 public.

使用 "==" 比较两个 primitive 数据类型, 或判断两个引用是否引用同一个对象.
使用 equals() 判断两个对象是否在意义上相等(如 两个 String 对象是否带有相同的字节组合).

局部变量: -- 栈变量.
  局部变量和方法参数都是被声明在方法中. 它们是暂时的, 且生命周期只限于方法被放在栈上的这段期间
  (也即方法调用至执行完毕为止)
实例变量:
  声明在类而不是方法里面. 它们代表每个独立的 "字段" (每个实例都能有不同的值)
  实例变量存在于所属的对象中(与对象一起在堆中).

局部变量的声明周期关联方法(方法出栈即销毁).
实例变量的生命周期关联对象(对象回收即销毁).
对象的生命周期: 取决于对象的引用. -- 只要有活着的引用, 对象也就会活着.
局部变量的状态在方法出栈之前会一直保存, 但是局部变量的只能在所在的方法在栈顶时才能使用,
 也就是说局部变量只能在声明它的方法在执行中才能被使用.

释放对象的引用(让对象变为 "可回收" 的三种方法):
  1. 引用永久性的离开它的范围. -- 方法出栈.
  2. 引用被赋值在新的对象上. -- 遥控器换了新的电视机.
  3. 直接将引用设定为 null. -- 空引用.

非 primitive 变量只是保存对象的引用而已, 而不是对象本身.
不论对象是否声明或创建, 如果局部变量是个对该对象的引用,
只有变量本身会放在栈上.
对象本身只会存在于堆上.(不论对象声明在哪里).

对象的创建:
 1. 声明引用变量: Duck duck; -- 如果是局部变量(属于方法), 在栈中(与方法同生共死); 如果是实例变量(属于对象), 在堆中.
 2. 创建对象: new Duck();
 3. 连接对象与引用(将对象赋值给引用): Duck duck = new Duck();

静态变量：
  1. 在该类的任何对象创建之前完成初始化;
  2. 在该类的任何静态方法执行之前就初始化.
常量:
  public: 方便读取.
  static: 类调用, 不需要实例.
  final: 不可变.

File 这个类代表磁盘上的文件, 但并不是文件中的内容.
 可以把 File 对象想象成文件的路径, 而不是文件本身.
 File 对象代表磁盘上的文件或目录的路径名称, 但它并不能读取或代表文件中的数据.
 (地址不是房子, File 对象代表特定文件的地址, 但不是文件本身.)
 例如 File 并没有读写文件的方法. 关于 File 有个很有用的
 功能就是它提供一种比使用字符串文件名来表示更安全的方式.
 举例来说, 在构造函数中取用字符串文件名的类也可以用 File 对象
 来代替该参数, 以便检查路径是否合法等, 然后再把对象传给 FileWriter/FileInputStream.

File 可以创建、浏览和删除目录.

关于缓冲区: BufferedWriter/BufferedReader.
 没有缓冲区, 就好像逛超市没有推车一样. 只能一次拿一样东西结账.
 缓冲区能让你暂时摆一堆东西直到满为止. 用了缓冲区就可以省下好几趟的来回.
将 FileReader 链接到 BufferedReader 可以提升效率.

多线程: multithreaded

端口: 0 ~ 65535 (0 ~ 1023 被保留为已知的特定服务)
 FTP: 20
 Telnet: 23
 SMTP(邮局交换服务器): 25
 Time: 37
 HTTP: 80
 POP3(邮件服务器): 110
 HTTPS: 443

引用相等性与对象相等性.
  如果 foo 与 bar 两对象相等, 则 foo.equals(bar) 会返回 true.
  且两者的 hashCode() 也会返回相同的值.
引用相等性:
  堆上同一对象的两个引用.
  引用到堆上同一个对象的两个引用是相等的. 就这样. 如果对两个引用调用 hashCode(),
  你会得到相同的结果. 如果没有被覆盖的话, hashCode() 默认的性为会返回每个对象特有的序号
  (大部分的 java 版本是依据内存位置计算此序号, 所以不会有相同的 hashcode).
  如果想要知道两个引用是否相等, 可以使用 == 来比较变量上的字节组合. 如果引用到相同的对象,
  字节组合也会一样.
对象相等性:
  堆上的两个不同对象在意义上是相同的.
  如果你想要把两个不同的对象视为相等的, 就必须覆盖过从 Object 继承下来的 hashCode() 方法与
  equals() 方法.
  就因为上面所说的内存计算问题, 所以你必须覆盖过 hashCode() 才能确保两个对象有相同的 hashCode,
  也要确保以另一个对象为参数的 equals() 调用会返回 true.

进入 .java 文件所在的顶层目录下(eg: src 目录)
% javac -d ../classes *.java



学编程的根本：与内存打交道
指针：指针就是地址，地址就是指针
指针变量：能够存放其他变量地址的变量
指针和指针变量是两个不同的概念，但是在一般叙述是把指针变量简称为指针
（从哲学上来讲，人无法用语言表达自己的思想，因为人的语言在叙述时，会省略一部分东西，另外，同样的一句话不同的人会有不同的理解）
（CPU和内存条之间有三条线：控制线，用来控制数据传输（读写）方向；数据线：用来数据传输；地址线：确定   对内存条的哪个单元进行操作）
指针：
	用来表示一些复杂的数据结构
	快速的传递数据
	使函数返回一个以上的值
	能直接访问硬件
	能够方便的处理字符串
	是理解面向对象语言中引用的基础
	
	总结：指针是C 语言的灵魂
	
指针的定义：
	地址
		内存单元的编号
		从零开始的非负整数
		范围:4G【0 -- 4G-1】（2的32次方）
	指针的本质就是一个操作受限的非负整数（指针非负，只能相减运算）

指针分类：
	基本类型指针
	指针和数组
	指针和函数
	指针和结构体
	多级指针	


int * p; // p 是变量的名字，int* 表示 p 变量存放的是 int 类型变量的地址
			// int * p， 不表示定义了一个名字叫 *p 的变量
			// int * p, 应该这样理解：p 是变量名，p 变量的数据类型是 int* 类型，
			// 所谓 int * 类型，实际就是存放 int 变量地址的类型
int i = 3;

p = &i; // 把 i 的地址赋值给指针变量 p，不能直接写 *p = i;(*p虽然没有赋值，p里面是一个垃圾值（地址），指向某个不确定的空间，这样写表示把i的值赋值给一个另一个空间)
			// 也就是说必须先给变量 p 赋值（只能给变量赋值，不能把 *p 当成变量，变量是 p）
			// 当指针变量定义但未赋值时，变量p里存放的是垃圾值（地址），这个值可以输出，但是这个地址的指向（即*p所代表的具体值）不确定，无法读取（没有权限）
/*
1. p 保存了 i 的地址，因此 p 指向 i；
2. p 不是 i，i 也不是 p，更准确的说：修改 p 的值不影响 i 的值，修改 i 的值不影响 p 的值不影响 p 的值
3. 如果一个指针变量 指向了某个 普通变量，则
		*指针变量 就完全等同于 普通变量
   例子：如果 p 是指针变量，并且 p 存放了普通变量 i 的地址，
		则 p 指向了普通变量；
		*p 就完全等同于 i
		或者说：在所有出现 *p 的地方都可以替换成 i；
				在所有出现 i 的地方都可以替换成 *p
  *p 表示以指针变量 p 的内容 为地址的变量（因为 p 的内容就是地址，p 里面存放的就是地址，而 *p 就是 p 中存放地址所代表（所指向）的变量本身）
   
  # include <stdio.h>
  
  void huhuan(int * p, int * q) //若这里形参写整型， a，b互换不了，因为形参互换不影响主函数的实参
  {								//但是当把主函数中 a，b 的地址值赋值给指针变量时，【*指针变量】就是a，b本身
	  int t; //这里如果换成指针变量t，下面的式子换成交换指针，那么交换的将是，指针变量p，q中保存的地址，也无法改变主函数中a，b的值
				// 同时，这里换成指针变量int* t，下面若换成 *t = *p；这样的式子，就犯了上面所说的错误（即，在指针变量没有赋值的情况下，不能访问 *指针变量这个未知的值）
				// 总而言之，只能给变量赋值。不能给 未知的【*变量】赋值，只能先给变量赋值，再获得 【*变量】的值
				//可以获得指针变量未赋值时，其中保存的垃圾地址值【p值】，但是无法获得这个垃圾地址值所指的
				// 也就是说，指针变量 p 必须先有一个地址（我们主动赋值给它的一个已知地址），然后才能把 一个具体整数赋值给 *p
				// 也可以认为，指针变量 p 必须先初始化为具体整型变量的地址（&i），然后才可以得到，*p = i；
				// p是变量，而 *p在p未被赋值时，是一个我们未知的另一个量
				// 变量的地址一旦分配将不可变，但是变量的赋值可以改变！！！（注意区别）
				// 指针变量在定义时不能直接赋值,如 int * p = 20;(或int * p; *p = 20;) 这样是错误的，必须先给指针变量p赋值，使变量初始化
				// 比如在 定义指针变量的同时定义一个整型变量：int *p，a; 然后把 a 的地址赋值给指针变量 p = &a（a的地址是系统分配的，一定是安全的）;
				//（此时*p就是a），接着给 *p赋值：*p = 20; 这样才可以。
				//或：int i = 20； int * p = &i;
	  
	  t = *p; // 这里*p和*q就变成了主函数中的实参本身，所以可以互相赋值（区别于上面说的 不能直接写 *p = i；的问题）
	  *p = *q;
	  *q = t;
  }
   
   int main(void)
   {
	   int a = 3;
	   int b = 5;
	   huhuan(&a, &b); // 想互换a，b 的值，必须获得a，b的地址
   }
   
*/

一维数组名和指针是一个含义：int a[6] = {1, 2, 3,  4, 5, 6};表示长度为6的元素，索引为0-5
则 a 保存了第一个元素（索引为0的元素）的地址，即数组的地址,是一个常量。a[3]表示3号索引（第四个元素）的值，即a[3]等价于*(a + 3);
指针变量的运算：只能相减（一般只有在数组中的各元素地址相减有实际意义），表示同一连续存储空间中不同单元的两个元素之间相隔的元素个数
eg：int * p, * q; p = &a[0]; q = &a[4]; 则 q - p = 4；表示 p所指向的单元与q所指向的单元隔了4隔单元

一个变量的地址只用第一个字节的地址表示，而具体字节的长度由数据类型确定
也就是说，对于任一类型的变量，将其地址赋值给一个指针变量，则该指针变量只指向该变量的第一个字节。而字节有多少个，指针变量无法判断

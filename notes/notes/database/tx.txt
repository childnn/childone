事务本质: (来源: Hibernate in Action)
   从一些背景信息开始. 应用程序功能要求同时完成几件事情. 例如, 当一次拍卖结束时, 应用程序必须执行 3 项不同的任务:
   1. 给胜出(金额最高)的出价做标记;
   2. 向卖主收取拍卖费用;
   3. 通知卖主和成功的出价人
  如果你由于外部信用卡系统的失败而无法收取拍卖费用, 会发生什么? 业务需求可能规定, 列出的所有动作必须要么都成功, 要么都失败.
  如果这样, 你可以把这些步骤全部称为事务 Transaction 或者工作单元. 哪怕只有一个步骤失败, 则整个工作单元都必定失败. 这就是
  大家所知的 原子性 Atomicity, 即所有操作都作为一个原子单元来执行.
  此外, 事务允许多个用户同时使用相同的数据, 而不破坏数据的完整性和正确性; 特定的事务不应该对其他同时运行的事务可见.
  为了完全理解这个隔离性 Isolation 行为, 有几个策略很重要... 后续

  事务具有其他重要的属性, 例如一致性 Consistency 和持久性 Durability. 一致性意味着事务始终工作在同一组数据上: 从其他同时运行
  的事务中隐藏起来的, 并在事务完成之后留在一个清洁和一致的状态中的一组数据. 数据库完整性规则保证一致性. 你也想要事务的正确性 Correctness.
  例如, 业务规则规定向卖主收取一次费用, 而不是两次. 这是个合理的假设, 但是你可能无法用数据库约束把它表达出来. 因而, 事务的正确性是应用程序
  的责任, 而一致性则是数据库的责任.
  持久化意味着一单事务完成, 所有变化都在该事务变成持久化期间进行, 即使系统后来失败了, 这些变化也不会丢失.
  把这些事务属性归结起来, 就是大家所知的 ACID 标准.
  数据库事务必须简短. 单个的事务通常只涉及单批数据库操作. 在实践中, 还需要一个概念, 允许你有长期运行的对话,
  在这里一个原子组合的数据库操作不是在一批而是几批中发生. 对话允许应用程序的用户用有思考时间, 而仍然保证原子, 隔离且一致的行为.
数据库把工作单元的概念实现为一个数据库事务 Database Transaction. 数据库事务组合了数据库访问操作--也就是 SQL 操作. 所有 SQL 语句
都在一个事务内部执行; 无法把 SQL 语句发送到数据库事务之外的数据库. 事务被确保以这两种方式之一终止: 要么完全被提交 Commit, 要么完全被回滚 Rollback.
因而, 我们说数据库事务是原子的.
为了在事务内部执行所有的数据库操作, 必须给这个工作单元的范围做标记. 必须启动事务, 并在某个时间点提交变化. 如果出现错误(在执行操作或者提交事务的时候),
就必须回滚事务, 把数据留在一致的状态中. 这就是大家所知的事务划分, 取决于你所使用的技术, 它涉及更多或者更少的手工干预.
一般来说, 启动和终止事务的事务范围可以在应用程序代码中编程式地设置, 或者声明式地设置.
1. 编程式的事务:
   在非托管环境中, JDBC API 被用来给事务范围做标记. 通过在 JDBC Connection 中调用 setAutoCimmit(false) 启动事务,
   并通过调用 commit() 终止它. 可以在任何时候通过调用 rollback() 强制立即回滚.
  在一个于几个数据库中操作数据的系统中, 特定的工作单元涉及对不止一个资源的访问. 既然如此, 你就无法单独通过 JDBC 实现原子性.
  你需要可以在系统事务 System Transaction 中处理几个资源的事务管理器 Transaction Manager. 这样的事务处理系统公开了与开发人员
  进行交互的 Java Transaction API(JTA). JTA 中的主 API 是 UserTransaction 接口, 包含 begin() 和 commit() 系统事务的方法.
  此外, Hibernate 应用程序中的编程式事务通过
2. 声明式事务
   在应用程序中, 当你希望在一个事务内部进行工作的时候要进行声明(例如, 在方法中使用注解). 然后处理这个关注点就是应用部署程序和运行时环境
   的责任了.

数据库(和其他事务系统)视图确保事务隔离性 Transaction isolation, 这意味着, 从每个并发事务的观点来看, 似乎没有其他的事务在运行.
传统上而言, 这已经通过锁 locking 实现了. 事务可以在数据库中一个特定的数据项目上放置一把锁, 暂时防止通过其他事务访问这个项目.
一些现代的数据库 Oracle/PGSQL 通过多版本并发控制 multiversion concurrency control, MVCC 实现事务隔离性, 这种多版本并发控制
通常被认为是更可伸缩的.


丢失更新: lost update. 如果两个事务都更新一个行, 让后第二个事务异常终止, 就会发生丢失更新, 导致两处变化都丢失.
     这发生在没有实现锁的系统中. 此时没有隔离并发事务.
脏读: Dirty read. 一个事务读取由另一个还没被提交的事务进行的改变.
    这很危险, 因为由其他事务进行的改变随后可能回滚, 并且第一个事务编写无效的数据.
不可重复度: Unrepeadtable read. 一个事务读取一个行两次, 并且每次读取不同的状态.
    例如, 另一个事务可能已经写到这个行, 并已两次读取之间提交.
 不可重复读的一个特殊案例是 二次丢失更新问题 Second lost undates problem. 想象两个并发事务都读取一个行: 一个写到行并提交,
 然后第二个也写到并行提交. 由第一个事务所作的改变丢失了. 如果考虑需要几个数据库事务来完成的应用程序对话, 这个问题就特别值得关注.
幻读: phantom read. 发生在一个事务执行一个查询两次, 并且第二个结果集包括第一个结果集中不可见的行, 或者包括已经删除的行时.
    不需要是完全相同的查询. 这种情形是由另一个事务在两次查询执行之间插入或者删除行造成的.
ANSI 事务隔离性级别
   标准的隔离性级别由 ANSI SQL 标准定义, 但是它们不是 SQL 数据库特有的. JTA 也定义了完全相同的隔离性级别.
   隔离性级别的增加带来了更高成本以及严重的性能退化和可伸缩性.
  1. 允许脏读但不允许丢失更新的系统, 据说要在 读取未提交 read uncommitted 的隔离性中操作.
     如果一个未提交事务已经写到一个行, 另一个事务就不可能再写到这个行. 但任何事务都可以读取任何行.
     但任何事务都可以读取任何行. 这个隔离性级别可以在数据库管理系统中通过专门的写锁来实现.
  2. 允许不可重复读取但允许脏读的系统, 据说要实现 读取提交 read committed 的事务隔离性. 这可以共享的读锁和专门的写锁来实现.
    读取事务不会阻塞其他事务访问行. 但是未提交的写事务阻塞了所有其他的事务访问该行.
  3. 在 可重复读取 repeatable read 隔离性模式中操作的系统既不允许不可重复读取, 也不允许脏读取. 幻读可能发生. 读取事务阻塞写事务
    但不阻塞其他的读取事务, 并且写事务阻塞所有其他的事务.
  4. 可序列化 serializable 提供最严格的事务隔离性. 这个隔离性级别模拟连续的事务执行, 好像事务是连续地一个接一个执行, 而不是
    并发地执行. 序列化不可能只用低级别锁实现. 一定有一些其他地机制, 防止新插入的行变成对于已经执行会返回行的查询的事务可见.




事务特性
事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。
原子性（atomicity）：一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。
一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。
持久性（durability）：一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
事务之间的几个特性并不是一组同等的概念：
如果在任何时刻都只有一个事务，那么其天然是具有隔离性的，这时只要保证原子性就能具有一致性。
如果存在并发的情况下，就需要保证原子性和隔离性才能保证一致性。
-------------------
数据库并发事务中存在的问题
如果不考虑事务的隔离性，会发生以下几种问题：
更新丢失(无锁, 无事务)
    不使用任何锁, 两个线程同时写同一个数据, 一个人的数据把另一个的覆盖了.
脏读(X 锁): 写 --> 读 --> 提交（回滚） --> 读   dirty read
    脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，
    而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。
    ---
    使用 X 锁(必须获取到 X 锁, 才能执行写操作. 当一个事务写数据时, 其他事务无法获取到 X 锁, 无法写数据),
    可以避免更新丢失. 但是, 无法避免脏读. 当一个事务获取到 X 锁, 执行写操作(其他线程都无法执行写操作),
    写入新数据完毕(未提交事务), 此时, 其他事务执行读操作, 得到的是 写事务 未提交的数据(新数据写入数据库但未提交事务);
    然后, 写事务 执行回滚操作, 此后, 读事务 再次读取数据, 得到的是回滚后的旧数据; 也就表示, 此前(写事务回滚之前)读取的
    是脏数据.
不可重复读(X, S 锁): 读 --> 写提交 --> 读  non-repeatable read
    不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值
    (这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，
    该事务需要用到的数据被另一个事务修改并提交了。
    不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。
    需要注意的是在某些情况下不可重复读并不是问题。
    ---
    同时使用 X、S 锁, 此两种锁互斥(二者不可同时加在同一个 数据 上). 写操作前必须获得 X 锁, 此时该数据无法再接受其他操作,
    直到锁释放; 读操作前加 S 锁, 读完后立即释放. 此时 脏读 就被解决了.
    此时出现新的问题: 读事务 获取 S 锁, 读完释放; 写事务获取 X 锁, 写完提交释放. 读事务再去执行读操作, 得到了与第一次不同的结果.
    此即不可重复读. -- 在某些情况下, 这种问题并不会造成影响, 只要读事务重新开启事务就可以得到新的数据.
幻读: A 写 --> B 写 --> A 读  phantom read
    幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，
    这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。
    而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，
    其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。
    幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，
    所不同的是不可重复读可能发生在 update,delete 操作中，而幻读发生在 insert 操作中。

排他锁，共享锁
排它锁（Exclusive），又称为 X 锁，写锁。
共享锁（Shared），又称为 S 锁，读锁。
读写锁之间有以下的关系：
一个事务对数据对象 O 加了 S 锁，可以对 O 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 O 加 S 锁，但是不能加 X 锁。
一个事务对数据对象 O 加了 X 锁，就可以对 O 进行读取和更新。加锁期间其它事务不能对 O 加任何锁。
即读写锁之间的关系可以概括为：多读单写

事务的隔离级别
在事务中存在以下几种隔离级别：
读未提交(Read Uncommitted)
    避免 更新丢失 问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。
    该隔离级别可以通过“排他写锁”(X 锁)实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。
读已提交(Read Committed)
    避免 数据丢失,脏读 问题。读取数据的事务允许其他事务继续访问该数据，但是 未提交的写事务 将会禁止其他事务访问该数据。
    这可以通过“瞬间共享读锁”(S 锁)和“排他写锁”(X 锁)实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，
    读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。
可重复读(Repeatable Read)
    避免 数据丢失,脏读和不可重复读，但是有时可能出现 幻读。读事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。
    Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，
    读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。
串行化(Serializable)
    解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
    仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
float: 第 1 位符号位, 接下来 8 位指数, 再接下来 23 位尾数
double: 第 1 位符号位, 接下来 11 位指数, 再接下来 52 位尾数

压缩：
$ jar -cvf a.war *   # 压缩当前目录
$ jar -cvf a.war *.html WEB-INF/  # 压缩指定文件/目录
$ jar -tf a.war  # 查看 war 包内容
$ jar -uf a.war WEB-INF/classes/org/anonymous/servlet/XXXX.class  # 替换修改的文件

==========================================================
计算机是怎样跑起来的(CS)
==========================================================

计算机的三个根本性基础:
 1. 计算机是执行输入, 运算, 输出的机器
 2. 程序(软件)是指令和数据的集合
 3. 计算机的处理方式有时与人的思维习惯不同

程序的流程:
   顺序, 条件分支, 循环
算法: 为了达到某个目的需要进行若干步处理. 例如为了达到 "计算出两个数相加的结果" 这个目的, 就需要
以此完成三个步骤, 即 "输入数值", "执行加法运算", "展示结果". 像这样的处理步骤, 被称为算法.
被明确定义的有限个规则的集合, 用于根据优先的步骤解决问题.
把解决问题的步骤无一遗漏地用文字或图(编程语言)表示出来, 步骤必须明确且优先.
---
变量: 数据的容器. 因为依靠指定地址的方式编写程序很麻烦, 所以在 C, Java 等几乎所有编程语言中, 都是使用变量
    把数据存储进内存, 或从内存把数据读出来.
    对于程序员来说, 并无需知道变量被存储到内存空间中哪个地址上了(变量的地址即 C 中的指针).
    因为程序运行时由操作系统为我们尚未使用的内存空间中划分出一部分分配给变量.
    变量是程序中数据存储的最小单位, 每个变量都对应着一块物理上的内存空间.
数组: 连续分配的一块特定大小的内存空间.
程序: 算法(处理问题的步骤)和数据结构(处理对象的数据的排列方式)
结构体: 把若干数据项汇集到一处并赋予其名字后所形成的一个整体.
 在 C 语言中, 结构体是数据的集合, 它将数据捆绑在一起, 使得我们可以将这些数据看作是一个整体. 而对结构体中的
 数据进行操作的函数却写在结构体外部. 然而在面向对象编程中, 将表示事务行为的函数也放入这个整体, 这就形成了对象
 的概念, 使得这个整体即能描述属性, 又能描述行为.

DB:
    键: 设定表和表之间的关系 Relationship
    索引: 提升数据检索速度的机制

UML: unified modeling language 统一建模语言
UML 规定的 九种图
 用例图(use case diagram) 表示用户使用程序的方式
 类图(class diagram) 表示类以及多个类之间的关系
 对象图(object diagram) 表示对象
 时序图(sequence diagram) 从时间上关注并表示多个对象的交互
 协作图(collaboration diagram) 从合作关系上关注并表示多个对象间的交互
 状态图(statechart diagram) 表示对象状态的变化
 活动图(activity diagram) 表示处理的流程等
 组件图(component diagram) 表示文件以及多个文件之间的关系
 配置图(deployment diagram) 表示计算机或程序的部署配置方法

OOP: object oriented programming 面向对象编程
 inheritance: 继承  通过继承已存在的类所拥有的成员而生成新的类.
 encapsulation: 封装  在类所有拥有的成员中, 隐藏掉那些没必要展现给该类调用者的成员.
 polymorphism: 多态  针对同一种消息, 不同的对象可以进行不同的操作.

LAN: local area network 局域网
WAN: wide area network 广域网
TCP/IP: transmission control protocol/internet protocol 传输控制协议和网际协议
  信息以电信号的形式在网线中传播, 为了交换信息, 必须在 发送者和接收者之间确定发送方式
  这种对信息发送方式的规定或约束就是 "协议" protocol.
 Hub: 集线器. 把各台计算机的网线互相连接在一起的集线设备.
 Router: 路由器. 把公司内的网络和互联网连接起来的设备. -- 把 LAN 连接到 WAN 上.

MAC 地址: media access control. 能够标识网卡的编号
  用 MAC 地址的编号来指定电信号的接收者.
  在每一块网卡所带有的 ROM (read only memory) 中, 都预先烧录了一个唯一的 MAC 地址.
  网卡的制造商负责确定这个 MAC 地址是什么. 而 MAC 地址是有制造商的编号和产品编号部分组成的,
  所以世界上的每一个 MAC 地址都是独一无二的.
cmd 命令:
 ipconfig /all  显示网络信息,网络连接状态
   显示的 physical address (物理地址) 用 "-" 分隔的 6 个十六进制数(每个数占 8 bit)
MAC 地址在硬件层面上标识网卡, 可以唯一标识各个接入互联网的计算机, 但是使用和查找 未经处理的
  MAC 地址是很不方便的. 因此, 在 TCP/IP 网络中, 除了硬件上的 MAC 地址, 还需要为每台计算机设定一个
  软件上的编号, 这个编号就是 IP 地址.
  通常把设定了 IP 地址的计算机称为 "主机"(Host), 因为 路由器也算是计算机的一种,所以它们也有 IP 地址.
  在 TCP/IP 网络中, 传输的数据都会携带 MAC 地址和 IP 地址两个地址.
  IP 地址是一个 32 位的整数, 每 8 bit 为一组, 组间用 "." 分隔, 分成 4 段表示.
  8 bit 所表示的整数换算成十进制后范围是 0~255, 因此可用作 IP 地址的整数时 0.0.0.0 ~ 255.255.255.255
  共 4294967696 个.

通过 IP 地址就可以轻松地对计算机进行分组管理了. 比如用 IP 地址中第一段到第三段的数值代表公司, 用第四段的数值
代表公司内部的计算机.
把 IP 地址中表示分组(LAN)的部分称作 "网络地址"(如 前三段), 表示各台计算机(主机)的部分成为 "主机地址"(第四段).

TCP/IP
 IP 协议用于指定数据发送目的地的 IP 地址以及通过路由器转发数据.
 TCP 协议用于通过数据发送者和接收者互相回应对方发来的确认信号, 可靠地传输数据.
 通常把像这样的数据传送方式称作 "握手" Handshake.
 TCP 协议还规定, 发送者要先把原始的大数据分割成以 "包" Packet 为单位的数据单元, 然后再发送,
 而接收者要把收到的包拼装在一起还原出原始数据.

硬件上发送数据的是网卡, 在网卡之上是设备驱动程序(用于控制网卡这类硬件的程序), 设备驱动程序之上是实现了 IP 协议的程序,
IP 协议之上则是实现了 TCP 协议的程序, 而再往上才是应用程序, 比如 Web 或电子邮件.
TCP 协议使用被称作 "TCP 端口号" 的数字识别上层的应用程序. TCP 端口号中有一些是预设的, 比如 Web 使用 80 端口, 电子邮件
端口 25(发送) 和 110(接收).


IP address: ip 地址.  eg: 202.26.186.240
Subnet mask: 子网掩码. 子网掩码的作用是标识出在 32 bit 的 IP 地址中, 从哪一位到哪一位是 "网络地址", 从哪一位到哪一位
   是 "主机地址".
   如: 255.255.255.240 -- 十进制  用二进制表示 1111111.11111111.11111111.11110000
   子网掩码中, 值为 1 的那些位对应着 IP 地址中的 网络地址, 后面为 0 的那些位则对应着 主机地址.
   因此, 255.255.255.240 这个子网掩码就表示, 其所对应的 IP 地址前 28 bit 是网络地址, 后 4 bit 是主机地址.
   4 个二进制数可以表示的范围是从 0000 到 1111, 共 16 个数. 而 0000 和 1111 有特殊的用途, 且 路由器占用一个数,
   所以, 16 个数实际可以被 13 台计算机使用. 和 MAC 地址一样, 每个 IP 地址的值都是独一无二的.

NIC: network interface card. 网卡. ethernet (以太)网卡.

CSMA/CD: carrier sense multiple access with collision detection. 带冲突检测的载波监听多路访问.
  carrier sense: 载波监听. 这套机制回去监听 (sense) 表示网络是否正在使用的电信号 (carrier).
  multiple access: 多路复用. 多个 (multiple) 设备可以同时访问 (access) 传输介质.
  with collision detection: 带冲突检测. 这套机制会去检测 (detection) 因同一时刻的传输而导致的电信号冲突 (collision).

DHCP: Dynamic Host Configuration Protocol 动态主机设置协议.
    DHCP 服务器上记录着可以被分配到 LAN 内计算机的 IP 地址范围和子网掩码的值. 作为 DHCP 客户端的计算机在启动时,
    就可以从中知道哪些 IP 地址还没有分配给其他计算机, 执行自动分配.
    DNS 服务器的 IP 地址也可以从 DHCP 服务器获取.
默认网关: 通常会设置为路由器的 IP. 路由器是从 LAN 通往互联网世界的入口(Gateway).

LAN 外网络的访问:
 如果数据的发送目的地就在本 LAN 中, 则可以直接发送数据而无需经过路由器转发.
 一个不属于 LAN 内计算机的 IP 地址会被附加到数据的发送目的地字段上. 这样的数据虽然会被 LAN 内计算机忽略,
 但不会被路由器忽略. 因为路由器的工作原理就是查看附加到数据上的 IP 地址中的网络地址部分, 只要发现这个数据不是发送
 给 LAN 内计算机的, 就把它发送到 LAN 外, 即互联网的世界中.
一台路由器的路由表只会记录通往与之相邻的路由器的路径.
通常把这种数据经过路由器转发的过程称为 "路由"(routing)


DNS: Domain Name System. 域名系统   域名与 IP
  将 www.grapecity.com 这样的域名解析成 210.160.205.80 这样的 IP 地址.
  这个过程称为 域名解析. DNS 服务器通常被部署在各个 LAN 中, 里面记录着 FQDN 和 IP 地址的对应关系表.
  世界范围的 DNS 服务器通过相互合作运转起来的. 如果一台 DNS 服务器无法解析域名, 它就会询问其他的 DNS 服务器.
  这套流程是自动进行的, 用户并不会意识到.
FQDN: Fully Qualified Domain Name. 完整限定域名.
  主机名 + LAN 域名.
  child.yzw.co.cn.
  这个名字和 IP 地址等价

ARP: IP 与 MAC 地址. Address Resolution Protocol 地址解析协议
在互联网中, 到处传输的都是附带了 IP 地址的数据. 但是能够标识作为数据最终接收者的网卡的, 还是 MAC 地址.
于是在计算机中就加入了一种程序, 用于实现由 IP 地址到 MAC 地址的转换, 这种功能被称作 ARP.
ARP 的工作方式很有意思. 它会对 LAN 中的所有计算机提问: "有谁的 IP 地址是 210.160.205.80 吗?
有的话请把你的 MAC 地址告诉我. " 通常把这种同时向所有 LAN 内的计算机发送数据的过程称为 "广播" Broadcast.
通过广播询问, 如果有某台计算机回复了 MAC 地址, 那么这台计算机的 IP 地址和 MAC 地址的对应关系也就明确了.
ARP 流程也是自动进行的.
如果为了查询 MAC 地址, 每次都要进行广播询问, 那么查询的效率就会降低. 于是 ARP 还提供了缓存功能,
当向各个计算机都询问完一轮之后, 就会把得到的 MAC 地址和 IP 地址的对应关系缓存起来(临时保存在内存中).
存起来的这些对应关系信息称作 "ARP 缓存表".


cmd 命令:
  route print # 显示 路由表
  hostname  # 查看主机名.
  tracert 主机名  # 查看路由链路
  ipconfig /all  # 主机名 + DNS 后缀  即是 FQDN.
  nslookup  # 查询 DNS 服务器 FQDN 和 IP 地址.
  arp -a  # 查看当前 ARP 缓存表中的内容.

类 是对象的定义
对象 是类的实例 instance(类的副本)

类的定义(创建):
  复用性, 可维护性, 如何对现实世界建模, 易用性等
  把相关的函数和变量汇集到类中.
类的使用:
  1. 仅 调用 类所持有的个别成员(函数和变量)
  2. 在类的 定义 中包含其他的类(这种方法成为 组合) - 把类作为成员变量放在一个类中
  3. 通过 继承 已存在的类定义出新的类

API: Application Programming Interface
  应用程序接口, 用来完成某项功能的类,接口或者方法.
SPI: Service Provider Interface
  服务提供接口, 提供继承或实现的类,接口,方法
API 是有实际功能的,可以直接使用  -- 针对 程序开发人员
SPI 是需要实现的(最经典的就是 java.sql.Driver 接口, 共数据库厂商实现具体的驱动) -- 针对 框架开发工程师

CRSF: cross-site request forgery 跨站请求伪造
   也称 one click attack/session riding, 缩写 CSRF/XSRF

token:
  Token 完全由应用管理,所以它可以避开同源策略
  Token 可以避免 CSRF 攻击(http://dwz.cn/7joLzx)
  Token 可以是无状态的,可以在多个服务间共享
  Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证,服务端认证成功,
  那么在服务端会返回 Tok7en 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位。
  如果这个 Token 在服务端持久化（比如存入数据库）,那它就是一个永久的身份令牌。

信息摘要: Message Digest. 从作为数字签名对象的文件整体中计算出的数值. 对比由文件整体计算出的信息摘要, 可以证明文件内容
是否被篡改. 加密处理过的信息摘要就是数字签名.

对称密钥加密技术: (秘密密钥加密技术)
   加密解密使用相同的密钥.
非对称密钥加密技术: (公开密钥加密技术)
   用于加密的密钥可以公开给全世界, 因此称为 "公钥".
   用于解密的密钥只有自己才知道, 称为 "私钥".
 发送方使用接收方提供的公钥加密信息, 接收方使用对应的私钥解密.
 公钥/私钥都由接收方生成, 公钥公布, 私钥保留.
非对称加密算法: RSA

CGI: Common Gateway Interface. 通用网关接口.
CDN: Content Distribution/Delivery Network // CDS: Content Delivery Service. 内容分发服务.
CDSP: Content Delivery Service Provider. 内容分发服务运营商.

CVS: Comma Separated Value 逗号分隔值

==========================================================
程序是怎样跑起来的(计算机组成原理)
==========================================================
程序: 指示计算机每一步动作的一组指令.
     程序是指令和数据的组合体.
   print("HelloWorld!");
   print 是指令, "HelloWorld!" 是数据.
机器语言: CPU 可以直接识别并使用的语言.
    CPU 能够直接识别和执行的只有机器语言. 使用 C, Java 等语言编写的程序, 最后都会转化为机器语言.
正在运行的程序存储在内存, 硬盘和磁盘等媒介上保存的程序被复制到内存后才能运行.
内存地址: 内存中, 用来表示命令和数据存储位置的数值.
    内存中保存命令和数据的场所, 通过地址来标记和指定. 地址由整数值表示.
计算机的构成元件中, 负责程序中的解释和运行的是 CPU.
    CPU 根据程序的指令来进行数据运算, 并控制整个计算机.
CPU 和内存是由许多晶体管组成的电子部件, 通常称为 IC(Integrated Circuit).
从功能方面来看, CPU 内部由寄存器, 控制器, 运算器和时钟四部分构成, 各部分之间的电流信号相互连通.
寄存器 可用来暂存指令、数据等处理对象, 可以将其看作是内存的一部分.
控制器 负责把内存上的指令, 数据等读入寄存器, 并根据指令的执行结果来控制整个计算机.
运算器 负责运算从内存读入寄存器的数据.
时钟 负责发出 CPU 开始计时的时钟信号 Clock Puzzle. 也有些计算机的时钟位于 CPU 外部.
内存, 通常指计算机的主存储器(Main Memory), 简称主存. 主存通过控制芯片等与 CPU 相连,
主要负责存储指令和数据. 主存由可读写的元素构成, 每个字节(8位)都带有一个地址编号. CPU 可以
通过改地址读取主存中的指令和数据, 当然也可以写入数据. 但有一点, 主存中存储的指令和数据会随着
计算机的关机而自动清除.
程序启动后, 根据[时钟]信号, [控制器]会从[内存]中读取指令和数据. 通过对这些指令加以解释和运行, [运算器]就会对数据进行运算,
[控制器]根据该运算结果来控制计算机.
所谓 "控制": 指数据运算以外的处理(主要是数据输入输出的时机控制). 比如内存和磁盘等媒介的输入输出, 键盘和鼠标的输入, 显示器和打印机输出等.
CPU 的四个构成部分中, 程序员只需了解寄存器即可, 其余三个都不用太过关注. 因为程序是把寄存器作为对象来描述的.
汇编: 将汇编语言编写的程序转化成机器语言的过程称汇编;
反汇编: 机器语言程序转化成汇编语言程序的过程称反汇编.
编译: 高级语言 -> 机器语言
反编译: 机器语言 -> 高级语言
汇编器: Assembler
编译器: Compiler
内存的存储场所通过地址编号来区分, 而寄存器的种类则通过名字来区分.
不同类型 CPU, 其内部寄存器的数量, 种类以及寄存器存储的数值范围都是不同的.
不过根据功能的不同, 可以将寄存器大致分为八类, 寄存器中的内容既可以是指令也可以是数据.
其中, 数据分为 "用于运算的数值" 和 "表示内存地址的数值" 两种.
数据种类不同, 存储该数值的寄存器也不同.
CPU 中每个寄存器的功能都不同. 用于运算的数值放在[累加寄存器]中存储, 表示内存地址的数值则放在[基址寄存器]和[变址寄存器]中存储.
----------------------------------八大寄存器-------------------------------------------------------------
累加寄存器: accumulator register 存储执行运算的数据和运算后的数据
标志寄存器: flag register 存储运算处理后的 CPU 的状态
程序计数器: program register 存储下一条指令所在内存的地址
基址寄存器: base register 存储数据内存的起始地址
变址寄存器: index register 存储基址寄存器的相对地址
通用寄存器: general purpose register 存储任意数据
指令寄存器: instruction register 存储指令. CPU 内部使用, 程序无法通过程序对该寄存器进行读写操作
栈寄存器: stack register 存储栈区域的起始地址
------------------------------------------------------------------------------------------------
CPU 就是具有各种功能的寄存器的集合体, 其中, 程序计数器, 累加寄存器, 标志寄存器, 指令寄存器, 栈寄存器都只有一个,
其他寄存器可有多个.
CPU 每执行一个指令, 程序计数器 的值会自动加 1(当执行的指令占据多个内存地址时, 增加与指令长度相应的数值).
然后, CPU 的控制器就会参照程序计数器的数值, 从内存中读取命令并执行. 也就是说, 程序计数器决定着程序的流程.
程序的流程分为顺序执行, 条件分支和循环三种. [顺序]执行是指按照地址内容的顺序执行指令. [条件分支]是指根据条件执行任意地址的指令.
[循环]是指重复执行同一地址的指令. 顺序执行的情况比较简单, 每执行一个指令程序计数器的值就会自增 1.
但若程序中存在条件分支和循环, 机器语言的指令就可以将程序计数器的值设定为任意地址(不是+1). 这样一来, 程序便可以返回
到上一个地址来重复执行同一个指令, 或者跳转到任意地址.
条件分支和循环中使用的跳转指令, 会参照当前执行的运算结果来判断是否跳转. 无论当前累加寄存器的运算结果是负数, 零还是正数,
标志寄存器都会将其保存, 也负责存放 溢出(overflow, 运算结果超出寄存器长度范围)和奇偶校验(parity check)的结果.
CPU 在进行运算时, 标志寄存器的数值会根据运算结果自动设定. 条件分支在跳转指令前会进行比较运算. 至于是否执行跳转指令,
则由 CPU 在参考标志寄存器的数值后进行判断. 运算结果的正,零,负三种状态由标志寄存器的三个位表示:
运算结果为正则标志寄存器的第一位为1, 零则第二位为1, 负则第三位为1.
函数调用: 需要在完成函数内部的处理后, 处理流程再返回到函数调用点(函数调用指令的下一个地址).
函数调用使用 call 指令, 而不是跳转指令. 将函数的入口地址设定到程序计数器之前, call 指令会把调用函数后要执行
的指令地址存储在名为栈的主存内. 函数处理完毕后, 再通过函数的出口来执行 return 命令. return 命令的功能是把保存在
栈中的地址设定到程序计数器中.
在编译高级编程语言的程序后, 函数调用的处理会转换成 call 指令, 函数结束的处理则会转换成 return 指令.
---
基址寄存器和变址寄存器, 通过这俩寄存器可以对主存上特定的内存区域进行划分, 从而实现类似数组的操作.
如果想要像数组那样分割特定的内存区域以达到连续查看的目的, 使用两个寄存器会更方便些.
例如, 查看 10000000 地址 ~ 1000FFFF 地址时, 可以将 10000000 存入[基址寄存器], 并使[变址寄存器]的值
在 00000000 ~ 0000FFFF 变化. CPU 会把基址寄存器+变址寄存器的值解释为实际查看的内存地址.
[变址寄存器]的值就相当于高级编程语言程序中数组的[索引]功能.
---
CPU 处理机器语言指令的主要类型和功能
数据转送指令: 寄存器和内存, 内存和内存, 寄存器和外围设备之间的数据读写操作
运算指令: 用累加寄存器执行算数运算,逻辑运算,比较运算和以为运算
跳转指令: 实现条件分支, 循环, 强制跳转等
call/return 指令: 函数的调用/返回调用前的地址
---
XOR/EOR: exclusive or, 异或 ^, 其中一方是 0, 另一方是 1 时, 结果为 1, 其他情况都为 0.
NOT: 非 !, 反转所有位
字节: byte, 8 位(bit). 字节是最基本的信息计量单位, 位是最小单位, 字节是基本单位.
内存和磁盘都使用字节单位来存储和读写数据, 使用位单位则无法读写数据. 因此字节是信息的基本单位.
用字节单位处理数据时, 如果数字小于存储数据的字节数(二进制数的位数), 那么高位补零.
如, 100111 这个 6 位二进制数, 用 8 位(1字节)表示时为 00100111, 用 16 位(2字节)表示时
为 0000 0000 0010 0111.
补数求解的变换方法: 取反 + 1.
将二进制数的值取反加 1 的结果, 和原来的值相加, 结果为 0.
虽然 0 非正非负, 但是考虑到符号位, 将其划分到正数中.
因此, 有符号数值范围, 在数值上, 负数最小值比正数最大值大一. 如, -128~127, 0~127 实际上也是 128 个数.
算术右移: 高位补原始符号位
逻辑右移: 高位补零
-4(1111 1100) 右移两位, 逻辑右移情况下, 符号位补零, 结果为 0011 1111, 十进制 63
                      算数右移情况下, 符号位补 1, 结果为 1111 1111, 十进制 -1
---
浮点数: 把小数用"符号 尾数*基数的指数次幂" 这种形式来表示.
小数点后四位用二进制数表示时的数值范围 0.0000~0.1111.
这里只能表示 0.5, 0.25, 0.125, 0.0625 这四个二进制数小数点后面的位权组合而成的小数.
二进制数            十进制数
0.0000              0
0.0001              0.0625   2^-4
0.0010              0.125    2^-3
0.0011              0.1875   2^-3 + 2^-4
0.0100              0.25     2^-2
0.0101              0.3125   2^-2 + 2^-4
0.0110              0.375    2^-2 + 2^-3
0.0111              0.4375   2^-2 + 2^-3 + 2^-4
0.1000              0.5      2^-1
0.1001              0.5625   2^-1 + 2^-4
0.1010              0.625    2^-1 + 2^-3
0.1011              0.6875   2^-1 + 2^-3 + 2^-4
0.1100              0.75     2^-1 + 2^-2
0.1101              0.8125   2^-1 + 2^-2 + 2^-4
0.1110              0.875    2^-1 + 2^-2 + 2^-3
0.1111              0.9375   2^-1 + 2^-2 + 2^-3 + 2^-4
---------
单精度浮点数: 共 32 位, 符号位 1 位, 指数部分 8 位, 尾数部分 23 位
    正数范围: 1.401298 * 10^-45 ~ 3.402823 * 10^38
    负数范围: -3.402823 * 10^38 ~ -1.401298 * 10^-45
双精度浮点数: 共 64 位, 符号位 1 位, 指数部分 11 位, 尾数部分 52 位
    正数范围: 4.94065645841247 * 10^-324 ~ 1.79769313486232 * 10^308
    负数范围: -1.79769313486232 * 10^308 ~ -4.94065645841247 * 10^-324
在上述范围中, 有些数值是无法用二进制精确表示的.
符号部分: 使用一个数据位来表示数值的符号. 该数据位是 1 时表示 负, 为 0 时表示 正或者零.
数值的大小用尾数部分和指数部分来表示. 例如, 小数就是用 "尾数部分 * 2 的指数部分次幂" 这样的形式
来表示的.
尾数部分: 将小数点前面的值固定为 1 的正则表达式
   由于整数部分固定为 1, 在实际中不会保存第一位的数据, 可节省一个数据位, 从而可表示更多的数据范围.
指数部分: EXCESS 系统表示
EXCESS 系统表现: 通过把 0 作为数值范围的中间值, 从而在不使用符号位的情况下来表示负值的表示方法.
  EXCESS 是"剩余的"意思. 例如, 把 01111111 看作是 0 的话, 比这个数小 1 的 01111110 就是 -1.
  当指数部分是 8 位单精度浮点数时, 最大值 11111111 = 255 的 1/2, 即 01111111 = 127(小数部分舍弃)表示的是 0,
  指数部分是 11 位双精度浮点数时, 11111111111 = 2047 的 1/2, 即 01111111111 = 1023(小数部分舍弃)表示的是 0.
  单精度指数部分二进制数 11111111 在 EXCESS 表示为 128 次幂(225-127=-128), 因此, 8 位情况下, 表示的范围就是
  -127次幂~128次幂.
单精度浮点数表示 0.75, 0-01111110-10000000000000000000000(符号位-指数部分-尾数部分)
指数部分 0111110 是十进制数 126, 用 EXCESS 系统表现就是 -1 (126-127=-1);
尾数部分, 根据正则表达式, 实际的尾数部分的整数部分为 1, 即 10000000000000000000000 实际上表示 1.10000000000000000000000 这个二进制数.
将尾数部分转为十进制, 结果就是 1.5;
因此上述单精度浮点数, 表示的就是 +1.5 * 2^-1, 即 0.75.
---
高级编程语言中的数据类型: 占据内存区域的大小和存储在该内存区域的数据类型
例如, C语言数据类型中的 short 类型, 它表示的就是占据 2 字节的内存区域, 并且存储整数.













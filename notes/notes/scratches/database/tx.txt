事务特性
事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。
原子性（atomicity）：一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。
一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。
持久性（durability）：一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
事务之间的几个特性并不是一组同等的概念：
如果在任何时刻都只有一个事务，那么其天然是具有隔离性的，这时只要保证原子性就能具有一致性。
如果存在并发的情况下，就需要保证原子性和隔离性才能保证一致性。
-------------------
数据库并发事务中存在的问题
如果不考虑事务的隔离性，会发生以下几种问题：
更新丢失(无锁, 无事务)
    不使用任何锁, 两个线程同时写同一个数据, 一个人的数据把另一个的覆盖了.
脏读(X 锁): 写 --> 读 --> 提交（回滚） --> 读
    脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，
    而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。
    ---
    使用 X 锁(必须获取到 X 锁, 才能执行写操作. 当一个事务写数据时, 其他事务无法获取到 X 锁, 无法写数据),
    可以避免更新丢失. 但是, 无法避免脏读. 当一个事务获取到 X 锁, 执行写操作(其他线程都无法执行写操作),
    写入新数据完毕(未提交事务), 此时, 其他事务执行读操作, 得到的是 写事务 未提交的数据(新数据写入数据库但未提交事务);
    然后, 写事务 执行回滚操作, 此后, 读事务 再次读取数据, 得到的是回滚后的旧数据; 也就表示, 此前(写事务回滚之前)读取的
    是脏数据.
不可重复读(X, S 锁): 读 --> 写提交 --> 读
    不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值
    (这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，
    该事务需要用到的数据被另一个事务修改并提交了。
    不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。
    需要注意的是在某些情况下不可重复读并不是问题。
    ---
    同时使用 X、S 锁, 此两种锁互斥(二者不可同时加在同一个 数据 上). 写操作前必须获得 X 锁, 此时该数据无法再接受其他操作,
    直到锁释放; 读操作前加 S 锁, 读完后立即释放. 此时 脏读 就被解决了.
    此时出现新的问题: 读事务 获取 S 锁, 读完释放; 写事务获取 X 锁, 写完提交释放. 读事务再去执行读操作, 得到了与第一次不同的结果.
    此即不可重复读. -- 在某些情况下, 这种问题并不会造成影响, 只要读事务重新开启事务就可以得到新的数据.
幻读: A 写 --> B 写 --> A 读
    幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，
    这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。
    而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，
    其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。
    幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，
    所不同的是不可重复读可能发生在 update,delete 操作中，而幻读发生在 insert 操作中。

排他锁，共享锁
排它锁（Exclusive），又称为 X 锁，写锁。
共享锁（Shared），又称为 S 锁，读锁。
读写锁之间有以下的关系：
一个事务对数据对象 O 加了 S 锁，可以对 O 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 O 加 S 锁，但是不能加 X 锁。
一个事务对数据对象 O 加了 X 锁，就可以对 O 进行读取和更新。加锁期间其它事务不能对 O 加任何锁。
即读写锁之间的关系可以概括为：多读单写

事务的隔离级别
在事务中存在以下几种隔离级别：
读未提交(Read Uncommitted)
    避免 更新丢失 问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。
    该隔离级别可以通过“排他写锁”(X 锁)实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。
读已提交(Read Committed)
    避免 数据丢失,脏读 问题。读取数据的事务允许其他事务继续访问该数据，但是 未提交的写事务 将会禁止其他事务访问该数据。
    这可以通过“瞬间共享读锁”(S 锁)和“排他写锁”(X 锁)实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，
    读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。
可重复读(Repeatable Read)
    避免 数据丢失,脏读和不可重复读，但是有时可能出现 幻读。读事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。
    Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，
    读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。
串行化(Serializable)
    解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
    仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。